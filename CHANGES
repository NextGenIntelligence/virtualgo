
Switched to using VAOs (26/5/2013):
-----------------------------------

    The first one suggested by the profiler:

    "Your application used the same vertex array configuration 
     for multiple consecutive calls to DrawArrays or DrawElements. 
     Use vertex array objects (VAOs) to encapsulate the vertex 
     array configuration, allowing optimal reuse of that configuration 
     across multiple draw calls. See documentation on GenVertexArrays 
     and BindVertexArray."

    Implemented. Difficult to tell if it's any faster.

    Last remaining option really is to run the stone mesh
    through a tri-stripper offline and render non-indexed
    tri-strips.

    I think this may be required because at tessellation
    level 3 we are sometimes dropping below 60fps with
    the full amount of stones.

    For the moment I'm reducing to tessellation level 2.

    UPDATE: Reduced the amount of rings tessellation that occur in the bevel.

    This appears to have allowed 60fps again with tessellation level 3.


Back to 60 by putting alpha blending at end of frame (26/5/2013):
-----------------------------------------------------------------

    Seems that I now need to do GPU level optimizations

    "Your application rendered opaque geometry after rendering 
     transparent or alpha tested geometry. For best performance, 
     render all opaque geometry before any transparent geometry."

    Moved star point and grid rendering to the end 
    of the frame since it uses alpha blending.

    This may improve performance.

    Shadows will need separate treatment, at the point 
    they are rendered to texture, the alpha blend of
    that texture can be deferred until the end of
    the frame. 

    Wow! The adjustment to move alpha blended objects
    to the end of the frame alone was enough to increase
    performance to 60fps with the higher res stone mesh!

    Grid and star point rendering needs depth testing.

    Need to add zbias to grid and star points.

    All sorted!


Reduced stone tessellation depth (26/5/2013):
---------------------------------------------

    How can I make it run faster?!

    The profile is not really giving me targets that 
    I can optimize further. So the question needs to
    be --- what exactly is slow?

    It's probably that the rendering is taking up
    a very large chunk of CPU, this the small amount
    of physics CPU is enough to push it over 60fps.

    How can I verify if this is true?

    Simple... don't render the stones and see what
    the framerate is...

    It could be that we are in fact GPU bound!

    *** VERIFIED ***

    When the stones are not rendered, the game runs
    at an easy 60fps.

    So the question then is --- what can I do now?!

    I dropped the stone tessellation from 3 to 2.

    This brought the render back up to 60.


Update to support 19x19 board (26/5/2013):
------------------------------------------

    Lets stop fucking around and address the real problem head-on.

    I need to demonstrate a full size 19x19 board working, with
    all the design challenges of zoom/focus/placement/movement
    and such solved.

    First, lets get a full 19x19 end-game board position
    from the Shusaku red-ear game.

    I want to define this in an array, as coding it specifically
    would be incredibly painful :)

    Don't collide against other planes.

    Wow it's incredibly slow (23fps!)

    It appears to be the physics.

    Add star points for 19x19

    Measure why the physics is running so slow.

    FindCellOverlappingObjects is extremely slow.

    My *guess* is that the linear search through the stone
    array to go from stone id -> stone instance is the cause.

    Start at 22fps.

    Add add a stone map (33fps)

    Remove validation of scene grid add/remove (45fps)

    Now we're back to 33fps?!

    10.1% -- FindCellOverlappingObjects    
     5.8% -- SceneGrid::GetCellIndex
     5.7% -- FindOverlappingObjects
     4.0% -- stoneMap.find
     1.6% -- UpdatePhysics
     1.4% -- ApplyCollisionImpulseWithWithFriction

    Clearly the scene grid and the finding object vs. 
    object collision is the current bottleneck.

    Can this be improved without ripping out the
    entire std container based implementation?

    There is one big optimization which needs to be done.

    If the current source cell has no objects in it,
    skip all additional processing and checking with
    adjacent cells. No intersecting object pairs are
    possible!

    Indeed this seems to make a large difference,
    after this change all the scene grid related
    calls drop down lower than the rendering CPU
    usage.

    4.5% -- RigidBody::UpdateTransform
    3.8% -- StoneMap::find
    3.0% -- FindCellOverlappingObjects
    2.5% -- ObjectMap::find (idpair)
    1.9% -- UpdatePhysics
    1.3% -- SceneGrid::GetCellIndex

    The situation is now strange. 

    It doesn't seem to run at a decent speed during
    development, however in profiler everything except
    render appears to be cheap and it runs at 60fps.

    So is the profile building the game in a non-debug
    mode with optimizations? Am I simply at the point
    now where I must develop in release build with
    optimizations enabled?

    How do I change this?

    Yes. Indeed, the code was being run in debug
    hence the slowness.

    http://stackoverflow.com/questions/5387076/running-a-release-build-with-xcode-4

    Now we are back to 52 fps.

    How to get the game running faster?! 

    It must *easily* make 60fps when run in release build.

    RigidBody::UpdateTransform is 5% of frame time. 

    Now only call it once or twice per-frame, not per-collision.

    Still hovering around 52fps... =p


Added smoothing to stone select height and drop snap (23/5/2013):
-----------------------------------------------------------------

    Stone lift is now smoothed, which looks better, but not great.

    To make the stone lift look good, we need proper collision
    between the biconvex solids.

    Also, added a nice lerp back to pre-drag position if stone
    cannot be placed in an empty spot.

    Also, in the case where the stone is dropped and the 
    row/column is adjusted, the xy adjustment on the stone
    is now smooth. Looks really good!

    When a stone is dragged from off the board,
    it feels wrong that it "disappears"

    Made it warp back to the original unconstrained position
    on the floor. Feels much better.

    Also, standardize lift on stone select.


More fixes to stone select and drog (23/5/2013):
------------------------------------------------

    Don't adjust the intersection plane when the stone
    is lifted up, instead stick with the intersection
    plane being at the center of the go stone, and
    calculate offset from there.

    When the go stone is lifted up, adjust the offset
    but remain at the same plane height.

    This should avoid unnecessary drift in stone dragging.

    Yep. Seems to work!


Misc bugfixes (22/5/2013):
--------------------------

    Adjusted game update to run before physics.

    Adjusted stone constraint to run before stone vs. stone.

    These two things combined fix the slight "bumping" of
    other stones when a stone was dropped over them and deleted,
    or snapped to it's original position on the grid.

    Fixed initial render frames having wrong matrices

    Lets assume that somehow objects are not getting
    properly updated in the scene grid.

    So, add a validation step that goes over each
    stone, and verifies that it is actually in the
    correct scene grid set for its current postion.

    If this is false, assert!

    Unfortunately... I implemented this and it doesn't
    assert.

    This means the logic error is in the collision
    detection and how it uses the scene grid, or
    inside the scene grid, eg. how it maps the objects
    to spaces in the world, maybe they are in a 
    consistent set in the world, but they don't have
    the property that the search for nearby objects
    always picks up everything.


Crash fix in multi-touch (22/5/2013):
-------------------------------------

    People are getting asserts in validate (3x)

    The asserts are here:

        assert( board.GetPointState( row, column ) == ( stone.white ? White : Black ) );

    I think this means that a stone think it is constrained to a point,
    but the point itself does not agree that it is black or white.

    Either, the point is empty when it should be black/white,
    or it is black when it should be white or vice versa.

    Probably empty.

    So... how can this happen? :)

    I believe that it is caused somehow by multi-touch

    Yes. A second touch was able to select the already
    selected stone, and of coures, get confused when
    you released the stone (dorking up the logical grid)

    Fixed by explicitly disallowing selecting of a
    stone that is already selected!


Move work on stone move and drop (22/5/2013):
---------------------------------------------

    Remember where the stone was initially dragged from

    If it is dropped on the board, but cannot find an
    empty grid point, revert to the original place.

    If the original place is now filled (multi-touch), 
    delete the stone. Not much we can do at this point.

    Also, adjusted the stone drop so it has an initial
    component downwards. This fixes the "floaty" feeling
    when the stone is released, like it is being pushed
    down vs. just being let go. 

    Feels better but I now think it wobbles a bit too
    much on drop and may get annoying. Need to think
    about what it should look and feel like.

    Perhaps the stone needs additional damping when
    it is placed, vs. normal motion.


Fixed flicking off the board (22/5/2013):
-----------------------------------------

    The fix for stone lifting/selection has broken
    the stone flicking on release.

    To fix I think it is necessary to track the
    previous stone position and update only when
    "TouchesMoved", eg. don't use the intersection
    point which adjusts also when the stone moves
    up in the "UpdateTouches" fn.

    This should allow both flicking and nice robust
    stone movement upwards.


More bugfixes (22/5/2013):
--------------------------

    When a stone is dropped off the board, it should
    not be deleted immediately. It should drop on 
    the floor and delete after a few seconds.

    There is a case where selecting a stone far side
    of the board will make it move incorrectly, like
    it has changed the shadow on the board, which 
    implies that actually it has moved in the XY
    plane.

    This is bad!

    Generally speaking as the stone lifts it must 
    have as an invariant that its motion is vertical
    only, this means adjusting the select plane to
    match correctly is essential, including recalc
    of the select plane intersection and offset,
    post-lift up.

    This is probably what is causing weird stuff.

    Fixed!


Misc bugfixes (21/5/2013):
--------------------------

    First, it would be good to have a MAXIMUM HEIGHT
    to lift to, to avoid the pathological lifting when
    stones are near each other.

    Next, I have disabled any momentum infer while
    stones are constrained, as it seems to be causing
    the random launchings.

    Lots of expansion has occured. 

    It is time to fix bugs and contract.

    Lots of systems are roughly coded and hacked in

    Pass over code and clean up.

    Add a validate step that cross-checks between
    the logical board view of what is going on,
    and the per-stone instance view of what grid
    point row,column they are attached to.

    This should catch any silly business.

    (Indeed, the stone id was not being set properly
     when a stone was dropped into a new point...)

    Can actually completely disable collision between
    selected stones and non-selected stones, this
    will stop the selected stones occasionally pushing
    against non-selected stones (not wanted) when 
    dragging over them.

    When you tap a stone, then hold but don't move
    the large impulse should not be applied.

    Right now it is, and it looks stupid.

    Fixed.


Fixed lots of bugs in stone drag and snap to grid (19/5/2013):
--------------------------------------------------------------

    Matt Ditton says that bringing stones together
    with multi-touch causes infinite motion.

    Probably multiple stones getting locked to the
    same grid point?

    There are some cases where the stones lift up 
    excessively, especially in views where the camera
    position is close to the board.

    I'm not sure what is going here, but it's *definitely*
    a bug and causes pretty weird shit when trying to move
    stones zoomed in.

    Annoying impulse is applied when you tap a stone,
    but don't move, then release. In this case, touch
    impulse should only be applied if the touch releases
    in a short amount of time. FIXED.

    There are cases where multiple stones appear to be
    able to be attached to a stone point.

    Add asserts when setting stone state and adding
    stone ids etc. To make sure that we cannot try
    to add a stone to a grid point that is already
    occupied.

    Found it. Was not re-adding the stone to the 
    logical board after moving it, hence multiple
    adds to the same point became possible.

    When moving a stone always search for the closest
    empty point in the 3x3 grid around the immediate
    drop point.

    This should avoid any false deletes on drops.

    Still some silly buggers when you multi-touch
    and drag two stones together. They seem to try
    to leap over each other? Need to exclude stones
    from consideration if they are selected!

    This has been fixed.

    
Fixed up stone tap impulse vs. select and drag (19/5/2013):
-----------------------------------------------------------

    For some reason the stone is lowering again while selected
    I'm guessing this is because the select Z is not updating
    to match the stone being pushed up.

    What is the best way to do this?

    After physics update, update touch and detect
    if the select Z needs to be lifted?

    This seems to work.

    Impulse should only be applied on tap, not hold
    therefore it seems it should be applied on touch
    ended, not touch began.

    Actually, motion of stone select and drag is a bit
    boring without any impulse on select, so split into
    two impulses, one at touches began, one if tapped
    and touch does not move.


Fixed up constraints and added z lift (19/5/2013):
--------------------------------------------------

    First need to find nearby stones in adacent cells
    for a given stone, other cells only need to be tested
    if the stone is close to the border of cells.

    Added code to find vector of StoneInstance* that can
    be used to push the selected stone above nearby non
    selected stones.

    Project selected stones above other stones.

    First, iterate across all stones after integration,
    but before any collision detection is performed.

    If the stone is selected, find nearby objects within 
    radius of its position: bounding sphere radius * 2

    Then find the heighest non-selected stone center position z
    out of all stones in this set.

    This is the start point for the algorithm.

    Next, in a simple for loop move the selected stone up x cms
    until its bounding sphere is not colliding with ANY of the 
    other stones.


Experiment with stone dragging and constraint (18/5/2013):
----------------------------------------------------------

    Experimented with double tap to zoom in to point

    Doesn't feel very good.

    Turn dragging back on.

    Add stones to logical board on initial placement,
    eg. set to "white" or "black"

    Add stone ids to logical board on initial placement.

    On stone selection, remove constraint data.

    When selecting a stone remove it from the logical board.

    This is important so the stone can be returned to its
    initial position and not see that position as being
    full!

    Stones that are unconstrained and not selected should
    be deleted after 2 seconds.

    When a stone is dropped find the XY of the stone center
    and constrain the stone to that point *if* that point
    is currently empty!

    Added cycle between top-down, 45 degrees and zoomed in
    camera angles. Let the players see the different options.


Added 3D camera angles (18/5/2013):
-----------------------------------

    I wanted to get some Z accelerometer action but
    currently there is no way to do this without 
    inducing undesirable motion in the stones.

    Perhaps a damping or some constraint that makes
    stones in locked mode want to prefer to orient 
    vertically when they are lifted off the board.

    Try placing the camera not directly down

    Looks pretty rad.

    Shadow looks like it doesn't match stone
    highlight position. Is this a result of pow
    lighting or an incorrect shadow matrix?

    Dropped to size 36. Nice middle ground stone.

    Accelerometer needs to be adjusted to be relative
    to camera position. Multiply by normal matrix?

    For now all that was required was flipping x/y
    and negating x (due to landscape orientation).


Work on locked mode with stone constraints (18/5/2013):
-------------------------------------------------------

    First pass lock to constraint

    Goal: Show that stones can be locked to grid and
    still behave plausibly when shook, without the
    game build ruined.

    Doesn't seem to be that good. It seems that
    the constraint needs to adjust velocity at
    the point like a collision detection constraint,
    otherwise the stone wobbles about stupidly.

    Attempting to clamp maximum jerk impulse to stop
    strange effects of constraint. I think this
    probably is the simplest method!

    Actually, even simpler. Just disable the launch
    momentum while in the locked mode.

    Separated out tilt from locked. Now can be
    unlocked, but not have gravity tilt enabled.

    Disable flicking in locked mode.

    Disable dragging for the moment, as it is broken.

    Get a new build out for feedback!


Initial stone position is now the end position for a real 9x9 game (17/5/2013):
-------------------------------------------------------------------------------

    Demonstrates that we can now simulate the required number of stones.

    There are still some issues with the solver obviously having lots of
    jitter due to one iteration, but the collision detection is fast enough
    to support this amount of stones.

    Also seems to be some small issue where stones sometimes do not collide,
    this appears to indicate that there is still some issue where the cell
    grid is not finding colliding pairs of objects where it should.


Fix bugs in scene grid (16/5/2013):
-----------------------------------

    Get the scene grid under unit test

    Fix the bugs with the scene grid

    Found it! 

    There was a problem with the index calculation 
    from integer x,y,z that would have resulted in
    incorrect index for stones based on position.

    Is this the only bug? Verify in game.

    Still problems where stones are not colliding.

    Add tests for add object, remove object, move object.

    Found a couple other logic errors with stones not
    being properly removed from the cells when moved.

    Seems to be working now in most cases, except it
    breaks down when objects are in different cells
    (expected)

    Generalize search between cells so I can easily
    compare multiple cells without lots of dupe code.

    Seems to be running fast enough with lots of stones!

    Extend nearest object pair search to adjacent cells


Minor fixes and tuning (15/5/2013):
-----------------------------------

    Fix jitter when stone is dragged off the screen

    Tuned accelerometer impulse


Added wabi-sabi to accelerometer impulses (12/5/2013):
------------------------------------------------------

    Previously impulses were applied uniformly to all stones. 

    This lead to really strange behavior where multiple stones
    had *exactly* the same motion in parallel.

    To fix this I've added a bit of variance to the impulse,
    per-stone, on the order of a scale +/- 10% per-component.

    This makes the stone reaction to impulses look much more
    natural, and in keeping with the japanese ideal of WABI SABI!!!


Fixed drift and coming to rest (12/5/2013):
-------------------------------------------

    Need to find what is causing the drift!
    
    The gravity acceleration is being reflected, leading to
    velocity being upwards at 0.5 * gravity * dt post-collision.

    This was hidden with multiple iterations because the gravity
    post-would adjust and move towards zero.

    I'm going to try a hack fix if the linear velocity z is
    less than some threshold up at end of frame, clear to zero.

    Works pretty well!


Added shader for black stones (12/5/2013):
------------------------------------------

    Found a really cool trick for making the black stones
    look realistic, hybrid diffuse + specular using POW,
    eg. take the normal diffuse dot and pow it.

    I've applied this to black stones making them look
    really realistic with pow 4, then backported to white
    stones and they look much better at pow 2 than basic
    diffuse.

    WOW!
    

Simple collision between stones (12/5/2013):
--------------------------------------------

    Iterate across potentially colliding object pairs

    When stones are colliding push each out of penetration along normal.

    There appear to be bugs in the scene grid. I cannot explain
    current behavior. It seems to work fine with a single grid
    cell, but more than one cell and it breaks down.

    Need to get the scene grid under unit test and verify correctness.

    If stone is selected, treat it as if it has infinite mass.

    (What to do with multiple stones selected?!)

    Put a white stone on each star point.

    Fix dragging bugs with the stone

    Get a new build out. First build with stone vs. stone collsion


Added overlapping objects test using scene grid (12/5/2013):
------------------------------------------------------------

    Add object pair struct

    Think about how to implement "FindOverlappingObjects"
    method in terms of object pairs.

    I'm going to need a fast lookup from object id -> stone instance.

    For the moment hacked up with a slow linear lookup

    Sort a,b ids so that a is always less than b. This lets me combine
    the two ids into a 32bit integer that eliminates (a,b) and (b,a)
    looking like different object pairs.

    Add an ObjectSet: std::set<IdPair> to filter out existing
    object pairs when comparing.

    Added simple, non-cache friendly broadphase filtering between
    stones, eg. get position from rigid body, filter if length squared
    between them is > bounding sphere radius squared.

    Pass over cell grid gathering pairs of potentially colliding objects.

    First, I'm doing a simple scheme where I only test objects within
    the current grid cell. This is incorrect, as it will miss object
    overlaps when objects are overlapping grid cells.

    Reduce to only a few stones.

    Print out set of potentially colliding objects per-frame
    to the TTY.

    Verify that this matches what I expect!


Added scene grid (12/5/2013):
-----------------------------

   Implement 3D scene grid for stone postitions

    Sketch out functions to clear, add/remove and move objects

    Call all the correct scene grid functions when placing
    objects, moving them in physics or drag/click etc.

    Implement simple insert and remove functions

    Implement move object function *simply* by just
    removing then adding again. This can be improved later.

    I've decided to only insert the object into the immediate
    cell that the object is inside. Neighbours can be handled
    elsewhere, eg. in physics overlap tests.

    Implement non-stupid version of object move function


Added "fat finger bonus" for stone select (11/5/2013):
------------------------------------------------------

    Add scale factor for ray vs. stone intersect

    This will make it easier to select stones around the edges
    (make them fatter)


Added multi-touch support for select, drag and flick (11/5/2013):
-----------------------------------------------------------------

    Prep for multi-touch by moving select data into struct in Touch.h

    Add select touches std::map

    Hook up map via touches

    Multi-touches work!


Re-implemented stone dragging and flicking (10/5/2013):
-------------------------------------------------------

    Made game instance data private

    Add selected flag to stone.

    "selected" flag to true on stone when picked.

    If selected in true on the stone treat it differently, eg.
    major damping, don't apply gravity, push out of board vertically
    etc (check old code for all cases...!)

    Apply impulse to stone on touch

    Add a function to find a stone by id.

    Now keep track of selected stone by id.

    When the touch is released, unselect the stone.

    Now, implement touch moved tracking.

    Implement dragging and flicking.

    Fixed some bugs in select + flicking


Implemented basic stone picking (10/5/2013):
--------------------------------------------

    Implement stone picking on touches began

    Add concept of "stone id" 32bit incremented with each add

    Log stone id on stone pick


Implement portable touch interface (10/5/2013):
-----------------------------------------------

    Implemented portable touch interface

    Settled on the simplest possible conversion:

    A dumb array of POD touch structs!

    Update to support multiple touches per-call

    Verified that touch conversion is working.


Parameterized physics update (10/5/2013):
-----------------------------------------

    Added gravity bool so I can turn it on/off dynamically

    Break out physics parameters into "PhysicsParams" struct

    This will allow GameInstance.h to control physics update,
    without having to add a shit-tonne of parameters to the 
    update physics function each time I want something.


WIP moving event handling into game instance (10/5/2013):
---------------------------------------------------------

    Add conversion function: CGPoint -> vec2f pixels

    Move PlaceStones into GameInstance.h

    Move OnDoubleTap into GameInstance.h

    Move OnSwipe into GameInstance.h

    Move matrix data into GameInstance.h

    Move matrix update into GameInstance.h

    Move IsScreenPointOnBoard into GameInstance.h

    Study the existing touch code. How to best move it into GameInstance.h?

    Ideally, I want to have the logic for responding to gestures to be
    platform independent. I don't necessarily see the need to make the
    gesture DETECTION code platform independent... that's not the hard
    part.

    Key point is that I want to move the stone selection and dragging
    and placement logic into GameInstance.h. This is necessary because
    it's about to become a lot more complex.

    I think this means that more of the touch stuff is going to
    move into GameInstance.h that I would otherwise do just for
    portability.

    Back up old touch handler code.

    Removed old touch code and everything that doesn't support
    multiple stones. We are starting from scratch!!!

    *** WOW: DISABLING GRAVITY IS A REALLY FUN MODE. PLAY GO IN SPACE! ***

    Add Touch.h

    Inside here add a concept of "TouchHandle" which typedefs
    to a 64bit pointer.

    Then, add a set of functions to query data from touch objects

    Next, in touch functions from OS, find a way to pass all touches
    into the GameInstance.h versions of touch handling.

    Also add touch set, which encapsulates the NSSet* of touches.


Got first build out with multiple stones (9/5/2013):
----------------------------------------------------

    Turn on locked mode by default

    Enable launch impulse while in locked

    Turn collision planes back on in locked mode. 

    I like this concept and value it more than I value 
    flicking stones off the screen!

    Added support for black stones, but it looks super weird
    so I've turned it off for now.

    Disabled double tap zoom toggle.

    Fix damping issues with stones

    Get a new build out to beta testers


Converted matrix math from GLK to vectorial (9/5/2013):
-------------------------------------------------------

    Consolidate all matrix math such that it doesn't use GLKMatrix. 
    This way the matrix math can be portable using vectorial.

    Hacked up mat3f dummy class to work with 3x3 matrix float layout

    Need a function to invert a matrix. Falling back to GLK for now.

    Converted board, floor, grid, point to use mat4f

    Converted stone to use mat4f    

    Convert shadow rendering to use mat4f

    Fixed board shadow on ground. Was selecting textured board mesh
    as non-textured vertices. Hence, garbage verts.

    Converted stone shadow on ground

    Converted stone shadow on board


Verify code still works in iOS (9/5/2013):
------------------------------------------

    Verify code still works on iOS post-backport

    Profile multiple stones code again -- is it faster?

     10.8% - ApplyCollisionImpulseWithFriction
      4.1% - StonePlaneCollision
      4.1% - RigidBody::GetVelocityAtWorldPoint
      2.6% - ClosestFeaturesBiconvexPlane_LocalSpace
      1.7% - RigidBody::UpdateTransform
      0.7% - RigidBody::UpdateMomentum

    It is definitely much faster. 

    I believe this is a result of fixing pass-by-value for vec3f


Back port to MacOSX demos (9/5/2013):
-------------------------------------

    Back port to unit tests, C++ demos etc (useful to have)

    Back port Collision.cpp

    Back port Tessellation.cpp

    Naive tessellation of biconvex is wrong rotation and seems inside out

    Fixed camera, rotation direction and lighting in tessellation demo

    Back port Support.cpp

    Lighting is jacked in support demo

    Support is incorrect.

    Fixed it. Sphere dot was wrong (?!)

    Backport Dynamics.cpp


Moving game code out to GameInstance.h (8/5/2013):
--------------------------------------------------

    Move ownership of key, non-render related objects into
    GameInstance.h. This is the start of the game code moving
    out of Objective-C.

    Moved accelerometer object back into view controller. It is singleton.

    Separate stone data and stone instance

    Stone data is the template data common across all stones (eg: biconvex)

    Stone instance has the rigid body and any data per-stone

    
Work in progress splitting out portable code from Obj-C (8/5/2013):
-------------------------------------------------------------------

    Fork the project "experimental"

    Now I want to move as much out of the ViewController.m
    and into Game.h and Game.cpp as possible.

    This way the game code is portable and not specific to iOS

    First I would like to move helper routines into separate header files

    Moved telemetry enums and strings into Telemetry.h

    Moved shadow matrix math into Render.h

    Move accelerometer related functionality into Accelerometer.h 
    with an interface that is pumped once per-frame with raw 
    accelerometer data from the UI

    Move all code that generates floor and board mesh etc. into
    a new header file: MeshGeneration.h. This code is completely
    portable so has no business being written in ObjC

    Actually, it would be nice to reduce code size by adding
    helper methods inside ViewController.m that generate the
    vertex buffers given a mesh, options would include textured
    mesh and non-textured mesh variants. This is done OFTEN
    and the code is very cut&paste annoying.

    Also added methods to help clean up buffers, programs
    and textures. Much less code to deal with now.

    Move the "updateDetection" method into Telemetry.h

    It will only be able to work with a single stone now
    at most, and that will need to be passed in, but this
    will remove a lot of state data from ViewController.m

    Make "updateDetection" work with single stone case

    Move physics simulation into its own method in Physics.h

    Clean up render method. It's really fat and a lot of code
    can be factored out and put into methods, eg. selectIBAndVB

    Add a function pointer which is called on the first
    counter increment. This will allow integration with
    testflight.

    Split out all OpenGL related stuff into OpenGL.h/m to keep
    the ViewController.m as clean and simple as possible :)

    Remove all the did become active notifications and paused
    I don't need it. Unneccessary complication.


Additional optimizations, reduce iterations (6/5/2013):
-------------------------------------------------------

    Split the simulation into two modes:

        1. Multiple iterations for single stone
        2. One iteration for multiple stones

    This is appropriate because these iterations include
    integration steps, collision detection etc. while in an
    iterative solver, only the collision response is iterated
    upon.

    Therefore this is close to the "actual performance" I can
    expect with this number of stones once iterative solver
    is implemented.

    Also, adjusted stones so that they have more damping
    as lots of moving stones just looks really weird when
    the board is covered with them.


Some basic optimizations to support lots of stones (3/5/2013):
--------------------------------------------------------------

    INITIAL PROFILE:

        15.4% - RigidBodyTransform::RigidBodyTransform
        10.0% - quat4f::toMatrix
         9.9% - StonePlaneCollision
         6.9% - ApplyCollisionImpulseWithFriction
         4.5% - RigidBody::Update
         4.0% - RigidBody::GetVelocityAtWorldPoint
         3.7% - RigidBody::GetKineticEnergy
         1.5% - ClosestFeaturesBiconvexPlane_LocalSpace
         1.0% - IntersectStoneBoard

    AFTER TRIVIAL OPTIMIZATIONS:

        18.9% - RigidBodyTransform::RigidBodyTransform
        13.0% - StonePlaneCollision
        12.0% - ApplyCollisionImpulseWithFriction
         9.2% - quat4f::toMatrix
         6.5% - RigidBody::GetVelocityAtWorldPoint
         2.6% - ClosestFeaturesBiconvexPlane_LocalSpace
         2.0% - RigidBody::Update
         0.9% - IntersectStoneBoard

    IDEA #1: Cache the rotation matrix and its transpose
    during integration. Rotation matrix only changes
    at this point. Don't recalculate during the frame!

        22.6% - StonePlaneCollision
         8.2% - ApplyCollisionImpulseWithFriction
         3.4% - StoneBoardCollision
         3.2% - RigidBody::GetVelocityAtWorldPoint
         2.8% - RigidBody::UpdateOrientation
         1.6% - IntersectStoneBoard

    Idea #2: Add an early out check for the stone vs. plane
    Calculating the support is a reasonable amount of work.
    It can be avoided by checking if the stone is further
    away from the plane than the bounding sphere first.

        11.2% - ApplyCollisionImpulseWithFriction
        10.9% - StonePlaneCollision
         5.3% - GetVelocityAtWorldPoint
         4.1% - StoneBoardCollision
         3.8% - ClosestFeaturesBiconvexPlane_LocalSpace
         3.3% - RigidBody::UpdateOrientation
         2.5% - IntersectStoneBoard
         1.1% - quat4f::toMatrix

    Idea #3: Maybe the vectorial library is not properly
    using the neon intrinsics! eg. it is falling back to
    scalar float operations. This could explain slowness!

        WRONG. Vectorial is confirmed running in NEON mode.


Work in progress to support multiple stones (2/5/2013):
-------------------------------------------------------

    Make sure unlocked mode still works with at rest

    Add support for multiple stones

    Lots of difficulties with selection, drag, flick stones.

    Also, shadows have lots of artifacts, eg. z-fighting
    (needs render to texture shadows to fix properly)

    Physics simulation bogs down with multiple stones, need to optimize!

    Luckily, renderer seems fine...

    Profiler suggests using VAO for stones. Makes sense.

    It's a little bit too soon to go with multiple stones.

    Leave the code general, so I can experiment with it, but turn
    it off, because it needs so much wore before I can get a build
    out with multiple stone support enabled.


Added at rest detection for stone rigid body (2/5/2013):
--------------------------------------------------------

    Fixes the position drift for the stone on the board

    But I should still work out what that was. Friction maybe?


Fixed the case where you accidentally place a stone while dragging (2/5/2014):
------------------------------------------------------------------------------

    When you are dragging a stone around with one finger 
    placement of a stone is disabled.

    Previously, was too easy to accidentally touch the board
    while dragging a stone and place a new stone down!
    

Added missing star point on tengen (2/5/2013):
----------------------------------------------

    Goddamnit was missing star point in center!

    
Implement locked mode (2/5/2013):
---------------------------------

    Gravity is always down

    Spin is disabled

    Flicking is disabled on the board surface

    You can drag a stone off the board and flick it offscreen

    Disabled placement of a stone off the board. 

    Was way too easy to accidentally touch the screen with the palm
    of your hand and generate a second touch that placed a stone
    on the floor. Uh. Not what I want.

    BUG: Sometimes the stone drifts upwards on the board when it should
    be at rest. I have no idea why this suddenly started happening =p


Changed stone placement to second touch (1/5/2013):
----------------------------------------------------

    Switched stone placement. Stone goes to second touch.

    This is required because when placing a real go stone the middle
    finger is touching and can push and slide the stone post placement

    With the previous scheme the index finger had the stone under,
    this was wrong!

    Extended so that you can hold a thumb off board, then tap multiple
    stones on the board quickly with single presses. NICE


Implement stone placement (1/5/2013):
--------------------------------------

    Implement a way to place the stone: one finger hold then tap
    to confirm the stone placement

    Hacked up the select mode to kick in on the first finger
    post-placement, so you can apply small adjustments and a 
    bit of english post-placement.


Added star points to the board (1/5/2013):
-------------------------------------------

    Add star points to 9x9 board

    Enable trilinear filtering. Was not enabled (!!!)
    

Enhanced go board grid rendering (1/5/2013):
---------------------------------------------

    Recover star point and line textures from original Virtual Go

    Render lines as textures

    Looks much better now, especially zoomed in!


Fix pops when dragging stone over board edges/corners (1/5/2013):
------------------------------------------------------------------

    When dragging stone, always push out along the vertical axis
    as this will avoid pops going over board edges.

    It also feels pretty nice! :)

    Except, if you drag a stone from the ground onto the board,
    then drag it over the ground, it snaps back to ground.

    To fix, I check the intersection of the stone vs. the ray
    during drag, and if it moves closer to the camera, I hold
    that depth as the plan of interaction.

    Now the stone moves UP onto the board plane when pushed out


Enhanced go board shadows on floor (1/5/2013):
-----------------------------------------------

    Need better shadows for the go board. 

    Halved the z height of the light source for the board case


Go side and corner collision cases working again (30/4/2013):
-------------------------------------------------------------

    Left and right side cases look good

    Top case looks good

    Fixed bottom case issue

    Bottom left corner case

    Bottom right corner case

    Top left corner case

    Top right corner case


Go board shadow working on board again (30/4/2013):
---------------------------------------------------

    There seems to be something wrong with the shadow matrix

    I have to pass in an inverted d for plane

    This makes me think that maybe it is assuming left handed?

    Project go stone shadow onto board

    Instead of doing scissoring I used a depth buffer hack
    to clip the shadow so it only shows up over the go board.

    Maybe the shadow matrix is correct but the right side has 
    incorrect winding?

    Nope. This theory is incorrect!

    Zoom in a bit less on iPad. It didn't work with the texture.


Projected board shadow onto ground (30/4/2013):
-----------------------------------------------

    Adjust collision to use go board instead of ground plane

    Adjust go board and grid render to render at z = thickness

    Adjust checkpoints to differentiate ground and board collision
    cases: sliding, spinning, come to rest etc.

    Project board shadow onto floor

    Hack fix z fighting between board and stone shadow on floor

    Extend board mesh to include sides (needed for shadow)

    There is z fighting for the bottom and left sides.

    I think this means they have the wrong winding.

    Yes, that was it. Fixed!

    Shadow projetion appears to be not actually correct.

    For example, the go board shadow should meet with the
    primary surface corner, but it falls short.

    I think this means the shadow matrix is slightly wrong

    Switched to lighter wood texture which looks really good
    against grey floor texture. A perfect match!


Added floor rendering (30/4/2013):
----------------------------------

    Fixed z fighting on grid

    Find suitable floor texture. It might tile. Kinda =)

    Add floor shader

    Generate floor mesh

    Render floor at z=0 plane with board disabled

    Adjust texture tiling so it looks reasonable zoomed OUT
    (will not be visible zoomed in, until scroll is implemented)


Added go board lines and 9x9 go board zoom out mode on iPad (30/4/2013):
------------------------------------------------------------------------

    Render go board lines first pass

    Adjust go board on iPad version to fit in 9x9 board

    Zoomed in should be *TRUE* on iPad initially, and should behave
    including everything like lighting, exactly like the previous
    version before I made the 9x9 board.

    Then I can preserve the behavior that I like, while adding
    a cool zoom out to get a real go board mode for people to
    discover!!!

    Need to retune shadow alpha fade-out in the zoomed out iPad
    version. Shadows are not fading out fast enough.

    Instanced actual go board 9x9. Use this to drive quad bounds
    for the 9x9 board, and the grid.

    Rotated go board texture 90 degrees so the grain is in the
    correct direction -- top to bottom along the long axis!


Added shadows (29/4/2013):
--------------------------

    Implement shadow shader

    Fixed problems with backface culling

    Render shadow with simple z=0 collapse

    Make sure shadow renders with proper alpha 
    and does not z-fight against the board quad.

    Render both stone and shadow

    Work out how to correctly project stone onto ground plane

    Tune the light location so the result looks OK on the side

    Tuned the shadow for iPhone

    Seems that we *absolutely* need to fade the shadow alpha out
    as the stone moves away from the board. It must be zero alpha
    but the time the stone gets near the light point


Added go board background texture (29/4/2013):
----------------------------------------------

    Load separate shaders for board and stone

    Switch between shaders ready for rendering

    Sketch out code to render the quad using vert buffer

    Learn how to feed in texture coordinates via vertex buffer

    Why is the stone still dropped from height? It should be spawned
    at position (0,0,0). I cannot see what is causing this?!

    Fixed. The stone was not being dropped. The smooth zoom
    was initialized to 0 which meant that it "pulled back" away
    from the stone on startup, making it look like the stone
    was falling.

    Switch to static vertex buffer for board

    Get the board texture rendered on the quad

    Tune the board quad dimensions and texture density

    Debug why weird stuff happens with uniform normal matrix on
    the go stone when I have multiple shader programs.

    Fixed. Uniforms were not being properly split across
    different programs, eg. the uniform for the stone shader
    was discarded when I loaded board shader.

    Fixed by having a separate array of uniforms for the stone
    and board shaders.


Small impulse applied when you touch the stone (28/4/2013):
-----------------------------------------------------------

    Apply a light impulse along the camera ray when first selecting a stone

    This way you can tap stones and they will react by wobbling,
    depending on where on the stone you touched.

    In practice this looks quite realistic!


Detected more complicated checkpoints (28/4/2013):
--------------------------------------------------

    Detect at rest on each plane

    Detect sliding on each plane

    Tuned flick vs. drag threshold

    Detect spinning on each plane

    Detect various device orientations:

     - perfectly flat
     - neutral (nearly flat)
     - left, right, up, down
     - upside down


Added testflight checkpoints for common interactions (27/4/2013):
-----------------------------------------------------------------

     - zoomed in
     - zoomed out
     - applied impulse
     - selected stone
     - dragged stone
     - flicked stone
     - tapped stone
     - bounced off near plane


Setup testflight, got a few beta testers (18/4/2013):
-----------------------------------------------------

    Get icon ready

    Integrate with testflight SDK and start distributing to testers

    Send Test flight invites to:

     - Paul Bragiel
     - Mark McCubbin
     - Dave Taylor
     - Morgan
     - Matt Ditton
     - Dave Jaffe
     - Go Game Guru
     - Thomas Rizos
     - Rex Guo

    Invite URL is http://tflig.ht/ZvH5xr

    Apparently I need to collect all their devices, then 
    make a build adding these devices to my provisioning
    profile.

    This is problematic as this profile seems to have max 99 devices?!


Fixed bug in select and drag, handle multi-touch (16/4/2013):
-------------------------------------------------------------

    Ray vs. plane intersection was not properly handling
    plane d, leading to the intersection being a mirror
    plane, rather than the intended plane.

    This manifested as popping and strange perspective 
    artifacts in stone select and drag.

    Cancel swipe/hold if multiple touches occur.

    Swipe is one finger only!

    Drag is one finger only!


Tweak launch (15/4/2013):
-------------------------

    Previously the launch only worked in the up direction

    I've changed it so that any jerk > 0.5 will launch in
    that direction.

    When you shake or move the iPhone about it now looks
    quite cool, like the stone is shaking about in there.

    The cost is that accidental bumps can move the stone
    a lot more than intended along the playing surface.


Drag stone (15/4/2013):
-----------------------

    Click and hold damps the stone rotation

    Detect click intersect with stone. Go into "select" mode

    While in select mode damp the stone rotation. Don't apply gravity.

    Calculate xy offset from stone center on first intersection,
    and depth of intersection z.

    Then intersect ray with that plane and calculate stone center
    using offset.

    Somehow this gives a perspective effect that is unpleasant.

    To fix I need to implement the offsetting in screen coords?

    Inherit velocity on stone release. Feels really good!


Spin on swipe (15/4/2013):
---------------------------

    Determine start and endpoint of swipe in screen space

    Determine swipe time in seconds

    Call a handler function with the data

    It seems that swipe time varies a lot for swipes
    that seem otherwise simular.

    This indicates that calculating exact "swipe velocity" is 
    probably not a good idea with the current setup. 

    This is because the velocity counts the start and end points, 
    and therefore includes any hold time before the swipe is fired
    off.

    But for now, I'm going to just assume that the only thing 
    I can extract is the start point and the swipe delta in
    screen space. Lets work with that!

    Convert swipe start point to a ray.

    Intersect this ray with a plane with normal +z
    through the center of the go stone.

    To calculate the direction of the angular moment, take the cross
    product of the swipe direction * swipe momentum constant and
    apply it as if applying angular part of velocity at a point.

    OK I tried all of this and it sucks.

    The solution is that on any swipe I apply an angular impulse
    around the up vector. This works well and is as simple as
    possible!


Swipe detection (15/4/2013):
----------------------------

    Simple built in swipe gesture does not provide starting point of swipe

    It is just one of four directions: left/right/up/down

    This is fine for flipping pages and so on, but it does not
    suit my needs. I need to know where the swipe is relative
    to the go stone, so I can work out the axis of rotation!

    It would seem that the smartest thing to do would be to detect
    a press down then set a flag then if a release is detected
    a certain distance away and within a certain time then this
    is a swipe.

    This gives me a direction of the start and end points of the swipe.

    Cancel swipe if it goes on too long, eg. 1 second


More iOS demo app tuning (15/4/2013):
-------------------------------------

    Home sick with a sore back :(

    Clamp z coordinate to be no larger than smoothZoom 
    (stop the stone rolling back behind your eye... !!!)

    Implement code to detect launching the stone up. WOW!

    If stone is just dropped and above frustum clamp velocity 
    so it cannot have z into the eye. 

    This stop the stone "sticking" when released holding the 
    phone upside down.


Work on iOS app (14/4/2013):
----------------------------

    Get basic stone physics into iOS app

    Get basic collision working with floor

    Hook up gravity to be driven by the accelerometer

    *** WOW!!! ***

    Tune elasticity and friction

    Add the jerk acceleration to the stone

    Adjusted to size 40 stone as it has a cool lazy wobble!

    Add collision planes for walls. Include, near, far and side planes.

    If the stone is within bounding sphere radius of near plane
    snap position to center - eye position axis

    If stone is close to the eye clear screen white

    Fix up code to get correct frustrum planes

    *** WOW!!! ***


Various post-GDC fixes (14/4/2013):
-----------------------------------

    Convert to right handed coordinates (WIP fixing up)

    Fixed biconvex support

    Fixed weirdness with camera zoom levels

    Fixed stone strafe sliding directions

    Contact point is wrong with biconvex vs. primary surface

    Re-enable energy kinetic energy post-collision test. Works with epsilon!

    Fix lighting in collision demo

    Remove VirtualGo.cpp demo -- too similar to collision demo

    Tessellation demo appears to be inside out?

    Why are cracks showing in tessellation demo? Not any more!

    Find a way to unify code between xcode and sublime codebases


Ported stone demo to iPad/iPhone (14/4/2013):
---------------------------------------------

    Simple OpenGL rendering with OpenGL ES 2.0

    Detected single tap vs. double tap

    Detected application wake up / sleep

    Disabled different orientations in app

    Read accelerometer value, lowpass to find gravity
    then take the highpass to detect acceleration jerks

    Determine appropriate zoom level for iPhone vs. iPad so the
    go stone at zoomed out mode is actual size, and in zoomed in
    mode does not clip against the screen bounds.


Separated collision demo, added video recording (17/3/2013):
------------------------------------------------------------

    Separate collision demo

    Add video capture to collision demo

    Add mode where go stone sticks on the board after push out

    Add mode where go stone penetrates the board and freezes

    Render contact point and normal in push out mode in red


Added video recording to support demo (17/3/2013):
--------------------------------------------------

    You can now record video from the support demo

    This gives a good visual demonstration of biconvex support
    witha rotating go stone projecting its bounds onto an axis
    with an orthographic projection.


Added dynamics demo and captured videos for article (16/3/2013):
----------------------------------------------------------------

    Add dynamics demo with:

        1. linear strobe once per-second
        2. linear smooth movement
        3. gravity
        4. angular motion
        5. combination linear and angular motion with gravity

    Add some way to get the strobe remember rigid body snapshots
    and render those. Snapshots should be taken every n seconds,
    where the accumulator is per-mode.

    Snapshots and accumulator should be cleared on mode change

    Tune the snapshots so they record good video / diagrams

    Demo record inputs and playback with video capture

    Capture all videos required for "How The Go Stone Moves"
    and upload to youtube.com

    Urgh. the video quality! =p


Fixed cracks in tesselation (7/3/2012):
---------------------------------------

    Epsilon was set too low when merging vertices, leading to 
    the normals of circle edge not matching with the normals
    of the biconvex, presumably leaving T-joins in the mesh
    between the sphere surface and the bevel torus.

    Increasing the epsilon value from 0.001 to 0.01 cms fixed
    the issue. Easy!

    This value should still be small enough to avoid any overly 
    aggressive vertex welds.


Fixed the damping decay factor so it is framerate independent (7/3/2012):
-------------------------------------------------------------------------

    With a simple adjustment using exponent it is verified to have the
    same amount of damping in super slow-motion as it does when the
    game is running full speed.

    This should also work for adjustments to the number of substep
    iterations in the physics engine as well (this adjusts the dt)


Applied black wood texture to go board (6/3/2012):
--------------------------------------------------

    The black texture looks particularly good with the 
    murasaki go stones!

    I think I'll take this to GDC as my demo.


Applied murasaki texture to go stone (6/3/2013):
------------------------------------------------

    Fixed the lights on the stone to look a lot better

    Create a new mode "Textured" (5)

    Integrate stb_image and load murasaki.jpg

    Create opengl texture objects

    Extend the tesselator so that it generates UV coordinates

    Extend the mesh render so it emits texture UVs

    Improve the lighting on the board

    Render the background as dark grey so black stones
    have some chance of being visible :)

    Work out why the fuck the texture is not showing up

    glGenerateMipmap :)

    Enabled anisotropic filtering

    Enabled trilinear filtering

    Apply murasaki texture to the go stone


Applied hacked damping and rolling/spinning friction (5/3/2013):
----------------------------------------------------------------

    The actual spinning/rolling friction specified in this paper
    is quite complicated and most likely overkill.

    http://physbam.stanford.edu/~fedkiw/papers/stanford2003-01.pdf

    Although it would be very nice to explore in the future,
    for now I've just created a hack with a variable amount 
    of damping propertional to the angualar velocity length.

    The trick was to have two values of damping while in contact
    a low damping value while angular rotation is large, and a
    smaller value for when angular rotation is small.

    To make the transition between these two values less obvious
    I added some interpolation between a transition angvel length
    range.

    This hack gives a reasonable approximation of what I want

     1. good coin spinning type movement
     2. rapid settling once the coin spin motion collapses
     3. good natural looking wobbles when coming to rest for all stones sizes

    So simple and works so good it should be a crime! :)


Fixed wireframe view, provide stone drop type selection (5/3/2013):
-------------------------------------------------------------------

    Fix the wireframe view, it's all broken with z-testing again

    Provide some way to select between initial stone drop conditions,
    
    eg:

        F1 = flat, 
        F2 = 45 degrees
        F3 = vertical
        F4 = 45 degrees more
        F5 = random orientation
        F6 = random orientation with spin


Finished edge and corner cases (5/3/2013):
------------------------------------------

    It is difficult to tell 100% but it seems that the stone is not
    colliding perfectly with the edge, but has some separation out
    from the edge -- sliding the stone off the edge then zooming in
    should help determine if this is actually happening

    No, it is working fine as shone by sliding the stone up onto the 
    side edge from off the board, it lines up perfectly.

    Need another key mapping for zoom level now that I'm using CTRL
    left/right/up/down to apply a linear impulse to the stone.

    Hacked it in, now zoom level is ALT-CTRL+UP/DOWN (shoot me)

    Implement the remaining side cases

    Implement bottom left corner case

    Bottom right corner

    Top left corner

    Top right corner


Work on left edge side for board (5/3/2013):
--------------------------------------------

    Implemented function to get nearest point on line and biconvex

    This will be used for the left edge

    Implemented the top and left side cases for the biconvex nearest
    point to the board, seem to be working OK.

    The plan for left side is as follows:

        1. Test the primary plane, but ignore if point is outside bounds
        2. Test the side plane, but ignore if point is outside bounds
        3. Test the edge, by definition cannot be outside bounds

    So far the first two cases are implemented and seem to be working

    Next I am hooking up the left side edge case

    Once this is done it should be relatively easy to generalize
    to all edges, eg. break up into a function so there is not
    a lot of cut & paste.

    Integrate nearest point on left edge case

    Visualized nearest point between stone and board. Seems to be working

    Why is the collision response suspect when hitting the side edge?

    Could it be that the normal is slightly incorrect?

    Should the normal be on the biconvex surface instead of the edge
    normal, is this what is wrong?!

    Found it: the nearest point on biconvex vs. line function was wrong

    Reworking the function so that it considers the sphere and the
    circle edge cases properly, and takes the closest point to the 
    line.

    There appears to be one final broken case now. Perhaps it is a fuckup
    with the top sphere vs. the bottom sphere? YES! It was!

    Need to be able to slide the stone off the edge

    Implemented this by adding linear impulse on CTRL + LEFT/RIGHT/UP/DOWN


Go board now has correct dimensions (4/3/2013):
-----------------------------------------------

    Find exact measurements of standard go board dimensions

    Parameterized board by the size (eg: 9, 13, 19), with the height
    of grid cells being slightly larger than the width (japanese style)

    Determine how much border there is for a standard japanese board (15mm)

    Separate the grid rendering from the rendering of the board

    Can now select board size on the fly:

        ALT-1: 9x9
        ALT-2: 13x13
        ALT-3: 19x19

    You can crash the demo if you increase the rotation too much with W
    so I added a clamp to maximum rotational inertia for any rigid body


Polish and new demo features (3/3/2013):
----------------------------------------

    Holding down tab scrolls to focus on the current stone

    If you hold down tab while the stone is moving, the camera 
    roughly tracks the stone

    Fixed the lighting

    Added a small impulse if the go stone is inside the go board
    at the beginning of the frame. This gives a cool trampoline effect
    when you adjust teh size of the go board on the fly.

    You now can add angular velocity with QWE and remove it with R


Lots of work on the GDC 2013 talk demo (2/3/2013):
--------------------------------------------------

    Remove the "Picking" demo as it is visually uninteresting

    Can now globally adjust go stone size via alt+left/right

    Added camera zoom levels driven by up/down 

    Make the go board have a center which is the grid point, not the 
    grid center. Asthetically any go player will find it strange otherwise
    (I do)

    Calculating the inertia tensor is too slow. Worked around with less precision

    Escape now restores defaults. For the moment this is just stone size 34

    Enter now drops a stone in the current mode

    Can now select side views in the board demo. 

    When dropping a stone in side view it drops exactly on the edge

    When switching to non-board views the view selection is reset to center

    Camera movement is now relative to the top of the board so it doesn't
    need to be adjusted for different height boards

    Can now adjust board height via ALT-UP/DOWN

    Switched zoom should be control-UP/DOWN because I need UP/DOWN for
    Z selection on the board, eg. ability to select center, sides and corners.

    Adjusted camera and lighting so +Z is forward into the screen when looking
    down the board side-on. Previously it was hacked up with +X into the screen

    The user can now scroll smoothly along the board with left/right/up/down

    Scrolling feels good now and is no longer limited to the small board

    Added more smoothing for the camera tween and now the view adjustments
    feel less jarring and acceptable. Still would be nicer for them to be
    ore analog than discrete, but it is "good enough" for the moment.

    Switch to the large board by default. Small/large board split removed.

    Demo initially does nothing (black screen) until user selects a demo

    Stone is now properly hidden when behind the board

    Can now scroll up/down in Y axis with A/Z. Height is clamped to
    not go below the top surface of the board.


Work on collision response with board (24/2/2013):
--------------------------------------------------

    Split out collision response into separate functions

    Update collision demo to use collision response functions

    Simplify collision detection with the board into a function
    that detects collision, does the projection out of the board
    and returns a static contact point.

    Collide first with the board then with the floor

    Implement collision detection with the floor and do it in
    the same form, eg. detect collision, perform the projection
    and return a static contact point.

    Adjust the board to have thickness and change it from the
    y=0 plane on the top. Floor should be y = 0, board is above

    Verify everything is working, eg. try a really small board

    Implement a function to render the board


Fixed energy being added by friction impulse (19/2/2013):
---------------------------------------------------------

    Was calculating tangent impulse based on velocity at point
    *before* applying normal impulse.

    In some cases this was adding energy to the system.

    Recalculating velocity at a point post-normal impulse and
    using this in the tangent impulse calculation stopped the
    energy from being added.
    

Switched from linear/angular velocity to momentum (18/2/2013):
--------------------------------------------------------------

    Previous code was using linear/angular velocity as the primary
    quantity.

    Switch to using momentum as primary and calculating linear
    and angular velocity from it as secondary quantities.

    Also fixed an error in the rotational kinetic energy calculation.

    Unfortunately, it still seems that coulomb friction impulse
    is adding energy to the system :(


Work on GDC 2013 talk (14/1/2013):
----------------------------------

    Plan out talk slides

    Determine the set of diagrams and demos that remain to be done

    Create first passes of the diagrams on pen and paper

    Work out what demo sections/visualizations are required

    Break up demo visualizations into separate demos that can
    be run and controlled via keyboard.


Finished tesselation demo (5/1/2013):
-------------------------------------

    Find a way to interpret 0-5 in the naive biconvex render
    so the naive tesselation changes with left/right as wall.

    Add a render mode to tesselation to view the stone
    not in wireframe. Ideally, this would be textured
    as well with better lighting but that can wait!


Properly weld bevel to biconvex at various tesselation levels (4/1/2013):
-------------------------------------------------------------------------

    left/right: adjust tesselation depth, 1 to maximum 5

    Find the vertices at the bottom edge of the biconvex top 
    and sort according to angle around the +y axis

    Next use these vertices as the start vertices for the bevel

    Finally, make the bevel # of rings be determined by the angle
    between the start and finish bevel, this way it should tesselate
    uniformly for various sizes of bevel.


Tesselated bevel torus + implement vertex welding (4/1/2013):
-------------------------------------------------------------

    Tesselate the bevel torus with quads.

    Create vertex buffer structure with normals

    vec3f position
    vec3f normal

    Sketch out interface to build mesh

    Implement grid cell -> hash bucket function

    Determine grid cell for vertex (x,y,z)

    Search in the bucket for a vertex with close enough position *and* normal!

    Add code to insert vertex into bucket if doesn't already exist (eg. push back on list)

    Verify that vertices have actually been welded (eg. print out per-weld w. static counter)

    If vertex is being added within epsilon of another grid cell,
    insert the index to that vertex in the other grid cell as well.

    Without vertex welding:

        18432 triangles
        55296 vertices
        55296 indices

    With vertex welding:

        18432 triangles
        9636 vertices
        55296 indices    

    With vertex welding + non-diagonal adjacent cells:

        18432 triangles
        9570 vertices       <--- correct! it is less!
        55296 indices

    With vertex welding + all adjacent cells (including diagonals):

        18432 triangles
        9570 vertices
        55296 indices


Calculated bevel torus for biconvex stone (3/1/2013):
-----------------------------------------------------

    Determine how to mathematically define the ideal
    torus for the smooth edge on the biconvex solid.

    The input should be the height of the bevel,
    this can then be used to determine the tangent
    at the edge of the sphere

    Knowing the tangent at the edge it should be 
    possible to determine the major and minor radii
    of the torus.


Improved stone tesselation added lighting etc. (1/1/2013):
----------------------------------------------------------

    Render the stone with gouraud shading

    Enable anti-aliasing

    Integrate GNU Tesselation Library
    http://gts.sourceforge.net/index.html

    Recover code from original Virtual Go that performed
    the tesselation of the go stone via GTS.

    Code is crap. Discarded.

    Subdivide the spherical cap by starting with a n-gon shape
    projected on to the sphere, and subdividing the triangles
    in the hexagon shape and projecting out to the sphere.

    5-gon seems to give best result (triangles close to equilateral)

    Generate the bottom of the biconvex

    Split up the code into headers to make it easier to manage


Solved strange energy adding effects (9/9/2012):
------------------------------------------------

    Reworked the collision response from scratch and verified 
    that no additional energy is added.


Calculated volume of biconvex solid (3/9/2012):
-----------------------------------------------

    Write a function to calculate the volume of the stone
    given biconvex width and height

    This means I'll need to do an integral for sphere volume
    but only for the top bit and bottom bits of the sphere

    Measure how much the stone weighs in real life

    Determine approximately what the density of the stone
    is, this will allow me to calculate the inertia tensor
    via the numerical integration

    Fixed a bug where linear impulse was not being scaled
    by inverse mass. This is explains the strange behavior
    that was occuring with different mass values.
    

Numerically integrated inertia tensor for biconvex solid (3/9/2012):
--------------------------------------------------------------------

    The inertia tensor is the sum of all moments (r^2*point mass)

    So I just iterated across the xyz bounds and summed up the
    moments numerically. This gives me an approximation for the
    inertia tensor which is pretty sweet.

    It seems that the ratio of the inertia tensor to the mass,
    or the *closeness* of it to 1.0 elements is quite important
    for the stability of the simulation.

    It would seem really that the only thing that matters is
    the ratio between the xz and the y inertia tensor, and (possibly)
    the ratio between the mass and the inertia tensor values

    But linear mass is probably irrelevent in the collision between
    stone and board, since the board is treated as having infinite
    mass.

    It would only kick in when I do stone vs. stone collision?

    No. I think it matters because the mass is an input to the
    collision response even vs. the board. Should study the effect
    that the ratio of the mass vs. the inertia tensor values has


Switched to ellipsoid inertia tensor (2/9/2012):
------------------------------------------------

    Write function for inertia tensor of a sphere given radius/mass

    Write function for inertia tensor of an ellipsoid    

    Retuned simulation based around inertia tensor given
    an ellipsoid with axes (1,0.5,1), which isn't EXACT
    but it's pretty damn close!


Switch to left handed coordinate system (2/9/2012):
---------------------------------------------------

    There is something wrong with my angular velocity math
    or with my velocity at point function, because I have
    had to explicitly invert the quaternion -> matrix
    conversion, and negate the angular impulse

    OpenGL coordinate system is right handed.

    Thought it was left handed. Switched!

    Verified that quat -> matrix needs transpose,
    otherwise rotation is in the opposite direction
    to what I expect.

    Verified that angular velocity is integrating properly
    eg. angular velocity of (0,0,20) rotates counter-clockwise
    around the z axis (positive direction, left handed rule)

    So then where is the inversion?

    It would SEEM that it must be inside my impulse calculation
    or in my velocity at point on rigid body function, because
    the angular velocity integration is working properly!


Implemented normal impulse and coulomb friction impulse (27/8/2012):
--------------------------------------------------------------------

    Calculate impulse as per-wikipedia entry formala
    for restitution:

    http://en.wikipedia.org/wiki/Collision_response

    Applied friction impulse from Erin's GDC tutorial


Aborted POI approach. I misunderstood speculative contacts! (21/8/2012):
------------------------------------------------------------------------

    There is some very strange problem with the collision
    response. It appears to get "stuck" often, indicating
    that the bisection is not 100% correct?

    My guess would be that the bisection is incorrectly
    thinking that the stone is moving towards the board
    and stopping dt advancement

    The collision response is not properly implementing
    the sort of sliding behavior I am looking for if a stone
    slides down on a surface edge it should slide out.

    It seems that my understanding of speculative contacts
    was entirely incorrect. It seems I am implementing
    something different, also I do not understand how
    rolling and sliding contacts work within speculative
    contacts...


Really crappy collision response + friction (19/8/2012):
--------------------------------------------------------

    Added a small amount of damping to linear and angular
    velocity so the system does not explode.

    Also added a totally bullshit friction impulse to the
    collision response so the impulse is not purely in the
    plane normal direction (the stone tumbles around)


First pass collision response (19/8/2012):
------------------------------------------

    Need a function to determine rigid body velocity at point

    Need a function to apply an impulse at a point

    Add a new demo for collision response (7)

    Perform collision response such that an impulse is applied
    that removes the velocity *into* the plane surface at the
    point of collision.


Added function to determine closest features on board and stone (18/8/2012):
----------------------------------------------------------------------------

    Now we need a function that gives us the closest point
    on the biconvex to the plane.

    Basically, we want to ask the question -- what is the 
    closest (or deepest) point on the biconvex re. the plane,
    and then we want to project this point onto the plane surface

    The logic on this should be similar to finding the point
    that is projected onto the axis for the SAT, eg. this 
    would be the point that becomes projected s1

    The normal should always be directly up.

    Extended function so that it returns separate points and normals
    on the stone and on the board, eg:

        stonePoint
        stoneNormal
        boardPoint
        boardNormal

    Visualized board point+normal as red line, and stone point+normal
    as yellow line. Verified that they are working properly.

    Worked around a problem with transforming a plane, the W coordinate
    was not being correctly transformed. Slow workaround function is 
    working properly in the interim.


Bisect to find point of stone/board collision (18/8/2012):
----------------------------------------------------------

    Bisect to find exact point of collision

    The stone moves so fast that it tunnels inside the plane
    when it falls from a height.

    Fix this by subdividing the step searching for the first
    time where the stone collides with the board.

    Freeze the stone at this time and verify visually
    that it is not penetrating with ortho projection.


Stone board collision test now uses SAT (18/8/2012):
----------------------------------------------------

    Convert stone vs. board intersection test to use SAT
    instead of using exact point/normal plane test w. biconvex

    We only care about the binary result we do not want the 
    collision point and normal.


Added bisection demo in ortho projection (9/8/2012):
----------------------------------------------------

    Now I can see the result of the collision and determ whether
    any penetration into the plane surface exists.

    Next step, implement the bisection!


Simple collision detection between stone and board (8/8/2012):
--------------------------------------------------------------

    Implement collision detection between stone and board

    First I just need a boolean function that just says:

        Stone vs. Board intersecting? (true/false)

    When the stone has collided, detect this and freeze it
    in place so it does not move until "space" is pressed.


Angular motion for stone (8/8/2012):
------------------------------------

    Bring back quaternion class

    Implement simple integration of angular velocity -> quat delta (spin)

    Convert position/quaternion combo to rigid body matrix

    Stone should now tumble as it falls

    Randomize initial stone angular velocity


First pass stone kinematics (7/8/2012):
---------------------------------------

    Added a new demo that shows a falling stone with linear motion only

    Stone falls under gravity and passes right through the board


Visualize nearest point on biconvex function (7/8/2012):
--------------------------------------------------------

    When ray is not hitting stone, draw a yellow line between
    the intersection with the plane and the nearest point on
    the biconvex surface.

    This will let me verify that the nearest point on biconvex
    relative to another point is correct -- the point will always
    by definition be *outside* the biconvex, otherwise the pick ray
    would have hit the biconvex stone first.


Implement ray vs. board intersection (7/8/2012):
------------------------------------------------

    Implement ray vs. plane intersection

    Implement ray vs. board intersection 
    (for the moment, just test the primary surface and verify
     that the ray hit is within width/height bounds on plane...)

    Detect whether ray is hitting board or stones via t

    Show normal when hitting board


Visualized biconvex support along x-axis (6/8/2012):
----------------------------------------------------

    The dot threshold was incorrect. Was 1-sphereDot,
    but sphereDot was the correct value.

    When looking at biconvex circle span with ortho projection
    it appears to be correct. The perspective was throwing it
    off!

    Biconvex support now looks visually correct!


Visualized stone + board (6/8/2012):
------------------------------------

    Visualize stone vs. board intersection with blue line
    from point out along normal

    Stone vs. board intersection point appears to be incorrect
    when the sphere surface is nearest to the plane.

    Fixed calculation for sphere surface intersection point.


Render stone + board (5/8/2012):
--------------------------------

    Find some way to switch between modes

        eg. 1 = rotating stone
            2 = stone + board

    Zoom out to show the stone from a distance without rotation

    Render the board in wireframe according to dimensions and some
    tesselation factor

    Now render the board and the stone in the same app


Implemented mouse picking (5/8/2012):
-------------------------------------

    Intersect ray with biconvex and render point and normal
    of intersection if exists.

    Don't hide the mouse

    Space toggles rotation of the stone

    Add function to get mouse xy coordinates 

    Turn mouse xy into pick ray
    http://stackoverflow.com/questions/2093096/implementing-ray-picking

    Verify that intersection under mouse *LOOKS* correct


Render go stone as quads (5/8/2012):
------------------------------------

    Extend go stone render to render in quad strips + triangle
    strips for top section.

    Render quads in wireframe

    Render quads in wireframe with backface culling


Render go stone in wireframe (5/8/2012):
----------------------------------------

    It should be reasonably easy to render a wireframe
    go stone at the origin, pick a # of segments, then
    radially rotate about the origin and draw

    Then extend this to support a rigid body transform
    for the go stone and render it with that

    Next, allow the go stone to rotate about an axis
    and visualize the intersection point and normal with
    the board in wireframe


Implemented stone vs. board primary surface case (4/8/2012):
------------------------------------------------------------

    To handle intersection between biconvex stone and plane:

        1. transform plane into biconvex local space
        2. determine intersection in local space (done)
        3. if intersecting, transform point/normal into world space

    Unit tested simple case at origin with no rotation.

    Unit tested translated away from origin with no rotation.

    Unit tested rotated 180 degrees at origin (upside down)

    Unit tested rotated 180 degrees away from origin.

    Unit tested +/- 90 degrees rotation cases away from origin 
    (circle edge of biconvex solid)

    I can now be confident that the local to world / world to 
    local, transform plane, transform point, transform normal
    fns are all working correctly.


Rigid Body Transform (2/8/2012)
-------------------------------

    Added "RigidBodyTransform" class with cached local -> world,
    and world -> local transforms.

    Added helper function to get world position from transform.

    Implemented rigid body transform inverse, eg. world -> local.


Added board class and stone vs. board collision type test (1/8/2012)
--------------------------------------------------------------------

    Added stone class with dimensions width, height and thickness.

    Categorized stone vs. board collision into cases, eg. primary
    surface, no collision, left edge, top-right corner etc.

    Sketched out stone vs. board collision test function logic

    Unit tested the board collision type function.


Implemented Biconvex vs. Biconvex SAT test (26/7/2012)
------------------------------------------------------

    Write function to determine projection of biconvex onto a line.

    Implement basic unit tests of the span across xyz axes

    Determine set of axes to test one biconvex vs. another. 
    I believe if it is all combinations of lines between sphere
    centers, and a line from the center of each biconvex through
    the circle plane, to the projection of the other biconvex center
    onto the circle plane. YES!

    Write a function that determines the projection of a biconvex
    with a rigid body transform onto a line. This will be used for
    determining the projection of the "other" biconvex.

    Implement a biconvex vs. biconvex SAT function which accepts
    world space position/up per-biconvex and returns true if they
    are intersecting.


Basic OpenGL display (24/7/2012):
---------------------------------

    Link to OpenGL, Carbon etc from premake

    Get a fullscreen opengl display going (bring in from "Cube" demo...)


Added intersection and collision functions for biconvex solid (22/8/2012)
-------------------------------------------------------------------------

    Restore basic biconvex class with math to determine sphere radius
    and offset for a given biconvex width and height.

    Get the vector library back up and running from scoopr. 
    Don't resurrect my own crappy library that isn't SIMD!!!

    Copy across useful code from old biconvex mathematics
    routines, eg. 

        0. ray vs. sphere
        1. ray vs. biconvex (local space)

    Quick test to determine if a point is inside the biconvex.

    Add a function to determine if a point is on the biconvex surface within epsilon.

    Determine normal given a point on the biconvex surface.
    This should accept an epsilon in which it determines that the point is on
    the circle edge, vs. being on the sphere edge. In the case of circle edge
    express the normal as outwards from the circle.

    Find closest point on biconvex to another point (point is outside the biconvex)

    This breaks down into:

        a) closest point on sphere -- easy
        b) closest point on circle -- project to xz plane, normalize and multiply by circle radius

    Determine dot at edge of biconvex (eg. within which the plane collision 
    will be a collision with the circle, not the sphere surface...)

    This angle can be determined by looking at the origin of one of the generating
    spheres, and determining the angle between the x axis, and the line to the side
    of the biconvex shape.

    Use this to rework the plane collision to determine the dot range
    in which the plane must collide with the circle, and not the sphere
    surfaces.

    Add tests for top, buttom and edge cases of biconvex vs. plane

    Fix the function so that the results are what we expect!

    Rework function so we get information about nearest point even
    if the plane and biconvex are not colliding yet.

    Get unit testing framework integrated into the project

    Convert all printf tests over to unit tests.

    Problem with nearest point on biconvex surface, it is giving NaNs
    for trivial points outside the biconvex, eg. (0,10,0) above the 
    biconvex should result in (0,0.5,0)

    Convert plane biconvex intersection. Make sure all three cases
    are properly tested:

        1. top surface
        2. sphere surface
        3. circle edge
    
    I still want a "pm dev" console app that I can use to just printf
    and explore various things, as well as "pm test" and "pm go" for
    the actual opengl program.

    For the moment the quickest way to get all this stuff going is to
    just have it all in VirtualGo.cpp. Over structuring is a waste of 
    my time.

    So to get this working have VIRTUALGO_TEST, VIRTUALGO_CONSOLE
    defined with separate behavior for these guys, and default
    is to run the real program (eg. "pm go")
