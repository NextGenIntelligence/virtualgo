
Implemented normal impulse and coulomb friction impulse (27/8/2012):
--------------------------------------------------------------------

    Calculate impulse as per-wikipedia entry formala
    for restitution:

    http://en.wikipedia.org/wiki/Collision_response

    Applied friction impulse from Erin's GDC tutorial


Aborted POI approach. I misunderstood speculative contacts! (21/8/2012):
------------------------------------------------------------------------

    There is some very strange problem with the collision
    response. It appears to get "stuck" often, indicating
    that the bisection is not 100% correct?

    My guess would be that the bisection is incorrectly
    thinking that the stone is moving towards the board
    and stopping dt advancement

    The collision response is not properly implementing
    the sort of sliding behavior I am looking for if a stone
    slides down on a surface edge it should slide out.

    It seems that my understanding of speculative contacts
    was entirely incorrect. It seems I am implementing
    something different, also I do not understand how
    rolling and sliding contacts work within speculative
    contacts...


Really crappy collision response + friction (19/8/2012):
--------------------------------------------------------

    Added a small amount of damping to linear and angular
    velocity so the system does not explode.

    Also added a totally bullshit friction impulse to the
    collision response so the impulse is not purely in the
    plane normal direction (the stone tumbles around)


First pass collision response (19/8/2012):
------------------------------------------

    Need a function to determine rigid body velocity at point

    Need a function to apply an impulse at a point

    Add a new demo for collision response (7)

    Perform collision response such that an impulse is applied
    that removes the velocity *into* the plane surface at the
    point of collision.


Added function to determine closest features on board and stone (18/8/2012):
----------------------------------------------------------------------------

    Now we need a function that gives us the closest point
    on the biconvex to the plane.

    Basically, we want to ask the question -- what is the 
    closest (or deepest) point on the biconvex re. the plane,
    and then we want to project this point onto the plane surface

    The logic on this should be similar to finding the point
    that is projected onto the axis for the SAT, eg. this 
    would be the point that becomes projected s1

    The normal should always be directly up.

    Extended function so that it returns separate points and normals
    on the stone and on the board, eg:

        stonePoint
        stoneNormal
        boardPoint
        boardNormal

    Visualized board point+normal as red line, and stone point+normal
    as yellow line. Verified that they are working properly.

    Worked around a problem with transforming a plane, the W coordinate
    was not being correctly transformed. Slow workaround function is 
    working properly in the interim.


Bisect to find point of stone/board collision (18/8/2012):
----------------------------------------------------------

    Bisect to find exact point of collision

    The stone moves so fast that it tunnels inside the plane
    when it falls from a height.

    Fix this by subdividing the step searching for the first
    time where the stone collides with the board.

    Freeze the stone at this time and verify visually
    that it is not penetrating with ortho projection.


Stone board collision test now uses SAT (18/8/2012):
----------------------------------------------------

    Convert stone vs. board intersection test to use SAT
    instead of using exact point/normal plane test w. biconvex

    We only care about the binary result we do not want the 
    collision point and normal.


Added bisection demo in ortho projection (9/8/2012):
----------------------------------------------------

    Now I can see the result of the collision and determ whether
    any penetration into the plane surface exists.

    Next step, implement the bisection!


Simple collision detection between stone and board (8/8/2012):
--------------------------------------------------------------

    Implement collision detection between stone and board

    First I just need a boolean function that just says:

        Stone vs. Board intersecting? (true/false)

    When the stone has collided, detect this and freeze it
    in place so it does not move until "space" is pressed.


Angular motion for stone (8/8/2012):
------------------------------------

    Bring back quaternion class

    Implement simple integration of angular velocity -> quat delta (spin)

    Convert position/quaternion combo to rigid body matrix

    Stone should now tumble as it falls

    Randomize initial stone angular velocity


First pass stone kinematics (7/8/2012):
---------------------------------------

    Added a new demo that shows a falling stone with linear motion only

    Stone falls under gravity and passes right through the board


Visualize nearest point on biconvex function (7/8/2012):
--------------------------------------------------------

    When ray is not hitting stone, draw a yellow line between
    the intersection with the plane and the nearest point on
    the biconvex surface.

    This will let me verify that the nearest point on biconvex
    relative to another point is correct -- the point will always
    by definition be *outside* the biconvex, otherwise the pick ray
    would have hit the biconvex stone first.


Implement ray vs. board intersection (7/8/2012):
------------------------------------------------

    Implement ray vs. plane intersection

    Implement ray vs. board intersection 
    (for the moment, just test the primary surface and verify
     that the ray hit is within width/height bounds on plane...)

    Detect whether ray is hitting board or stones via t

    Show normal when hitting board


Visualized biconvex support along x-axis (6/8/2012):
----------------------------------------------------

    The dot threshold was incorrect. Was 1-sphereDot,
    but sphereDot was the correct value.

    When looking at biconvex circle span with ortho projection
    it appears to be correct. The perspective was throwing it
    off!

    Biconvex support now looks visually correct!


Visualized stone + board (6/8/2012):
------------------------------------

    Visualize stone vs. board intersection with blue line
    from point out along normal

    Stone vs. board intersection point appears to be incorrect
    when the sphere surface is nearest to the plane.

    Fixed calculation for sphere surface intersection point.


Render stone + board (5/8/2012):
--------------------------------

    Find some way to switch between modes

        eg. 1 = rotating stone
            2 = stone + board

    Zoom out to show the stone from a distance without rotation

    Render the board in wireframe according to dimensions and some
    tesselation factor

    Now render the board and the stone in the same app


Implemented mouse picking (5/8/2012):
-------------------------------------

    Intersect ray with biconvex and render point and normal
    of intersection if exists.

    Don't hide the mouse

    Space toggles rotation of the stone

    Add function to get mouse xy coordinates 

    Turn mouse xy into pick ray
    http://stackoverflow.com/questions/2093096/implementing-ray-picking

    Verify that intersection under mouse *LOOKS* correct


Render go stone as quads (5/8/2012):
------------------------------------

    Extend go stone render to render in quad strips + triangle
    strips for top section.

    Render quads in wireframe

    Render quads in wireframe with backface culling


Render go stone in wireframe (5/8/2012):
----------------------------------------

    It should be reasonably easy to render a wireframe
    go stone at the origin, pick a # of segments, then
    radially rotate about the origin and draw

    Then extend this to support a rigid body transform
    for the go stone and render it with that

    Next, allow the go stone to rotate about an axis
    and visualize the intersection point and normal with
    the board in wireframe


Implemented stone vs. board primary surface case (4/8/2012):
------------------------------------------------------------

    To handle intersection between biconvex stone and plane:

        1. transform plane into biconvex local space
        2. determine intersection in local space (done)
        3. if intersecting, transform point/normal into world space

    Unit tested simple case at origin with no rotation.

    Unit tested translated away from origin with no rotation.

    Unit tested rotated 180 degrees at origin (upside down)

    Unit tested rotated 180 degrees away from origin.

    Unit tested +/- 90 degrees rotation cases away from origin 
    (circle edge of biconvex solid)

    I can now be confident that the local to world / world to 
    local, transform plane, transform point, transform normal
    fns are all working correctly.


Rigid Body Transform (2/8/2012)
-------------------------------

    Added "RigidBodyTransform" class with cached local -> world,
    and world -> local transforms.

    Added helper function to get world position from transform.

    Implemented rigid body transform inverse, eg. world -> local.


Added board class and stone vs. board collision type test (1/8/2012)
--------------------------------------------------------------------

    Added stone class with dimensions width, height and thickness.

    Categorized stone vs. board collision into cases, eg. primary
    surface, no collision, left edge, top-right corner etc.

    Sketched out stone vs. board collision test function logic

    Unit tested the board collision type function.


Implemented Biconvex vs. Biconvex SAT test (26/7/2012)
------------------------------------------------------

    Write function to determine projection of biconvex onto a line.

    Implement basic unit tests of the span across xyz axes

    Determine set of axes to test one biconvex vs. another. 
    I believe if it is all combinations of lines between sphere
    centers, and a line from the center of each biconvex through
    the circle plane, to the projection of the other biconvex center
    onto the circle plane. YES!

    Write a function that determines the projection of a biconvex
    with a rigid body transform onto a line. This will be used for
    determining the projection of the "other" biconvex.

    Implement a biconvex vs. biconvex SAT function which accepts
    world space position/up per-biconvex and returns true if they
    are intersecting.


Basic OpenGL display (24/7/2012):
---------------------------------

    Link to OpenGL, Carbon etc from premake

    Get a fullscreen opengl display going (bring in from "Cube" demo...)


Added intersection and collision functions for biconvex solid (22/8/2012)
-------------------------------------------------------------------------

    Restore basic biconvex class with math to determine sphere radius
    and offset for a given biconvex width and height.

    Get the vector library back up and running from scoopr. 
    Don't resurrect my own crappy library that isn't SIMD!!!

    Copy across useful code from old biconvex mathematics
    routines, eg. 

        0. ray vs. sphere
        1. ray vs. biconvex (local space)

    Quick test to determine if a point is inside the biconvex.

    Add a function to determine if a point is on the biconvex surface within epsilon.

    Determine normal given a point on the biconvex surface.
    This should accept an epsilon in which it determines that the point is on
    the circle edge, vs. being on the sphere edge. In the case of circle edge
    express the normal as outwards from the circle.

    Find closest point on biconvex to another point (point is outside the biconvex)

    This breaks down into:

        a) closest point on sphere -- easy
        b) closest point on circle -- project to xz plane, normalize and multiply by circle radius

    Determine dot at edge of biconvex (eg. within which the plane collision 
    will be a collision with the circle, not the sphere surface...)

    This angle can be determined by looking at the origin of one of the generating
    spheres, and determining the angle between the x axis, and the line to the side
    of the biconvex shape.

    Use this to rework the plane collision to determine the dot range
    in which the plane must collide with the circle, and not the sphere
    surfaces.

    Add tests for top, buttom and edge cases of biconvex vs. plane

    Fix the function so that the results are what we expect!

    Rework function so we get information about nearest point even
    if the plane and biconvex are not colliding yet.

    Get unit testing framework integrated into the project

    Convert all printf tests over to unit tests.

    Problem with nearest point on biconvex surface, it is giving NaNs
    for trivial points outside the biconvex, eg. (0,10,0) above the 
    biconvex should result in (0,0.5,0)

    Convert plane biconvex intersection. Make sure all three cases
    are properly tested:

        1. top surface
        2. sphere surface
        3. circle edge
    
    I still want a "pm dev" console app that I can use to just printf
    and explore various things, as well as "pm test" and "pm go" for
    the actual opengl program.

    For the moment the quickest way to get all this stuff going is to
    just have it all in VirtualGo.cpp. Over structuring is a waste of 
    my time.

    So to get this working have VIRTUALGO_TEST, VIRTUALGO_CONSOLE
    defined with separate behavior for these guys, and default
    is to run the real program (eg. "pm go")
