
Moving game code out to GameInstance.h (8/5/2013):
--------------------------------------------------

    Move ownership of key, non-render related objects into
    GameInstance.h. This is the start of the game code moving
    out of Objective-C.

    Moved accelerometer object back into view controller. It is singleton.

    Separate stone data and stone instance

    Stone data is the template data common across all stones (eg: biconvex)

    Stone instance has the rigid body and any data per-stone

    
Work in progress splitting out portable code from Obj-C (8/5/2013):
-------------------------------------------------------------------

    Fork the project "experimental"

    Now I want to move as much out of the ViewController.m
    and into Game.h and Game.cpp as possible.

    This way the game code is portable and not specific to iOS

    First I would like to move helper routines into separate header files

    Moved telemetry enums and strings into Telemetry.h

    Moved shadow matrix math into Render.h

    Move accelerometer related functionality into Accelerometer.h 
    with an interface that is pumped once per-frame with raw 
    accelerometer data from the UI

    Move all code that generates floor and board mesh etc. into
    a new header file: MeshGeneration.h. This code is completely
    portable so has no business being written in ObjC

    Actually, it would be nice to reduce code size by adding
    helper methods inside ViewController.m that generate the
    vertex buffers given a mesh, options would include textured
    mesh and non-textured mesh variants. This is done OFTEN
    and the code is very cut&paste annoying.

    Also added methods to help clean up buffers, programs
    and textures. Much less code to deal with now.

    Move the "updateDetection" method into Telemetry.h

    It will only be able to work with a single stone now
    at most, and that will need to be passed in, but this
    will remove a lot of state data from ViewController.m

    Make "updateDetection" work with single stone case

    Move physics simulation into its own method in Physics.h

    Clean up render method. It's really fat and a lot of code
    can be factored out and put into methods, eg. selectIBAndVB

    Add a function pointer which is called on the first
    counter increment. This will allow integration with
    testflight.

    Split out all OpenGL related stuff into OpenGL.h/m to keep
    the ViewController.m as clean and simple as possible :)

    Remove all the did become active notifications and paused
    I don't need it. Unneccessary complication.


Additional optimizations, reduce iterations (6/5/2013):
-------------------------------------------------------

    Split the simulation into two modes:

        1. Multiple iterations for single stone
        2. One iteration for multiple stones

    This is appropriate because these iterations include
    integration steps, collision detection etc. while in an
    iterative solver, only the collision response is iterated
    upon.

    Therefore this is close to the "actual performance" I can
    expect with this number of stones once iterative solver
    is implemented.

    Also, adjusted stones so that they have more damping
    as lots of moving stones just looks really weird when
    the board is covered with them.


Some basic optimizations to support lots of stones (3/5/2013):
--------------------------------------------------------------

    INITIAL PROFILE:

        15.4% - RigidBodyTransform::RigidBodyTransform
        10.0% - quat4f::toMatrix
         9.9% - StonePlaneCollision
         6.9% - ApplyCollisionImpulseWithFriction
         4.5% - RigidBody::Update
         4.0% - RigidBody::GetVelocityAtWorldPoint
         3.7% - RigidBody::GetKineticEnergy
         1.5% - ClosestFeaturesBiconvexPlane_LocalSpace
         1.0% - IntersectStoneBoard

    AFTER TRIVIAL OPTIMIZATIONS:

        18.9% - RigidBodyTransform::RigidBodyTransform
        13.0% - StonePlaneCollision
        12.0% - ApplyCollisionImpulseWithFriction
         9.2% - quat4f::toMatrix
         6.5% - RigidBody::GetVelocityAtWorldPoint
         2.6% - ClosestFeaturesBiconvexPlane_LocalSpace
         2.0% - RigidBody::Update
         0.9% - IntersectStoneBoard

    IDEA #1: Cache the rotation matrix and its transpose
    during integration. Rotation matrix only changes
    at this point. Don't recalculate during the frame!

        22.6% - StonePlaneCollision
         8.2% - ApplyCollisionImpulseWithFriction
         3.4% - StoneBoardCollision
         3.2% - RigidBody::GetVelocityAtWorldPoint
         2.8% - RigidBody::UpdateOrientation
         1.6% - IntersectStoneBoard

    Idea #2: Add an early out check for the stone vs. plane
    Calculating the support is a reasonable amount of work.
    It can be avoided by checking if the stone is further
    away from the plane than the bounding sphere first.

        11.2% - ApplyCollisionImpulseWithFriction
        10.9% - StonePlaneCollision
         5.3% - GetVelocityAtWorldPoint
         4.1% - StoneBoardCollision
         3.8% - ClosestFeaturesBiconvexPlane_LocalSpace
         3.3% - RigidBody::UpdateOrientation
         2.5% - IntersectStoneBoard
         1.1% - quat4f::toMatrix

    Idea #3: Maybe the vectorial library is not properly
    using the neon intrinsics! eg. it is falling back to
    scalar float operations. This could explain slowness!

        WRONG. Vectorial is confirmed running in NEON mode.


Work in progress to support multiple stones (2/5/2013):
-------------------------------------------------------

    Make sure unlocked mode still works with at rest

    Add support for multiple stones

    Lots of difficulties with selection, drag, flick stones.

    Also, shadows have lots of artifacts, eg. z-fighting
    (needs render to texture shadows to fix properly)

    Physics simulation bogs down with multiple stones, need to optimize!

    Luckily, renderer seems fine...

    Profiler suggests using VAO for stones. Makes sense.

    It's a little bit too soon to go with multiple stones.

    Leave the code general, so I can experiment with it, but turn
    it off, because it needs so much wore before I can get a build
    out with multiple stone support enabled.


Added at rest detection for stone rigid body (2/5/2013):
--------------------------------------------------------

    Fixes the position drift for the stone on the board

    But I should still work out what that was. Friction maybe?


Fixed the case where you accidentally place a stone while dragging (2/5/2014):
------------------------------------------------------------------------------

    When you are dragging a stone around with one finger 
    placement of a stone is disabled.

    Previously, was too easy to accidentally touch the board
    while dragging a stone and place a new stone down!
    

Added missing star point on tengen (2/5/2013):
----------------------------------------------

    Goddamnit was missing star point in center!

    
Implement locked mode (2/5/2013):
---------------------------------

    Gravity is always down

    Spin is disabled

    Flicking is disabled on the board surface

    You can drag a stone off the board and flick it offscreen

    Disabled placement of a stone off the board. 

    Was way too easy to accidentally touch the screen with the palm
    of your hand and generate a second touch that placed a stone
    on the floor. Uh. Not what I want.

    BUG: Sometimes the stone drifts upwards on the board when it should
    be at rest. I have no idea why this suddenly started happening =p


Changed stone placement to second touch (1/5/2013):
----------------------------------------------------

    Switched stone placement. Stone goes to second touch.

    This is required because when placing a real go stone the middle
    finger is touching and can push and slide the stone post placement

    With the previous scheme the index finger had the stone under,
    this was wrong!

    Extended so that you can hold a thumb off board, then tap multiple
    stones on the board quickly with single presses. NICE


Implement stone placement (1/5/2013):
--------------------------------------

    Implement a way to place the stone: one finger hold then tap
    to confirm the stone placement

    Hacked up the select mode to kick in on the first finger
    post-placement, so you can apply small adjustments and a 
    bit of english post-placement.


Added star points to the board (1/5/2013):
-------------------------------------------

    Add star points to 9x9 board

    Enable trilinear filtering. Was not enabled (!!!)
    

Enhanced go board grid rendering (1/5/2013):
---------------------------------------------

    Recover star point and line textures from original Virtual Go

    Render lines as textures

    Looks much better now, especially zoomed in!


Fix pops when dragging stone over board edges/corners (1/5/2013):
------------------------------------------------------------------

    When dragging stone, always push out along the vertical axis
    as this will avoid pops going over board edges.

    It also feels pretty nice! :)

    Except, if you drag a stone from the ground onto the board,
    then drag it over the ground, it snaps back to ground.

    To fix, I check the intersection of the stone vs. the ray
    during drag, and if it moves closer to the camera, I hold
    that depth as the plan of interaction.

    Now the stone moves UP onto the board plane when pushed out


Enhanced go board shadows on floor (1/5/2013):
-----------------------------------------------

    Need better shadows for the go board. 

    Halved the z height of the light source for the board case


Go side and corner collision cases working again (30/4/2013):
-------------------------------------------------------------

    Left and right side cases look good

    Top case looks good

    Fixed bottom case issue

    Bottom left corner case

    Bottom right corner case

    Top left corner case

    Top right corner case


Go board shadow working on board again (30/4/2013):
---------------------------------------------------

    There seems to be something wrong with the shadow matrix

    I have to pass in an inverted d for plane

    This makes me think that maybe it is assuming left handed?

    Project go stone shadow onto board

    Instead of doing scissoring I used a depth buffer hack
    to clip the shadow so it only shows up over the go board.

    Maybe the shadow matrix is correct but the right side has 
    incorrect winding?

    Nope. This theory is incorrect!

    Zoom in a bit less on iPad. It didn't work with the texture.


Projected board shadow onto ground (30/4/2013):
-----------------------------------------------

    Adjust collision to use go board instead of ground plane

    Adjust go board and grid render to render at z = thickness

    Adjust checkpoints to differentiate ground and board collision
    cases: sliding, spinning, come to rest etc.

    Project board shadow onto floor

    Hack fix z fighting between board and stone shadow on floor

    Extend board mesh to include sides (needed for shadow)

    There is z fighting for the bottom and left sides.

    I think this means they have the wrong winding.

    Yes, that was it. Fixed!

    Shadow projetion appears to be not actually correct.

    For example, the go board shadow should meet with the
    primary surface corner, but it falls short.

    I think this means the shadow matrix is slightly wrong

    Switched to lighter wood texture which looks really good
    against grey floor texture. A perfect match!


Added floor rendering (30/4/2013):
----------------------------------

    Fixed z fighting on grid

    Find suitable floor texture. It might tile. Kinda =)

    Add floor shader

    Generate floor mesh

    Render floor at z=0 plane with board disabled

    Adjust texture tiling so it looks reasonable zoomed OUT
    (will not be visible zoomed in, until scroll is implemented)


Added go board lines and 9x9 go board zoom out mode on iPad (30/4/2013):
------------------------------------------------------------------------

    Render go board lines first pass

    Adjust go board on iPad version to fit in 9x9 board

    Zoomed in should be *TRUE* on iPad initially, and should behave
    including everything like lighting, exactly like the previous
    version before I made the 9x9 board.

    Then I can preserve the behavior that I like, while adding
    a cool zoom out to get a real go board mode for people to
    discover!!!

    Need to retune shadow alpha fade-out in the zoomed out iPad
    version. Shadows are not fading out fast enough.

    Instanced actual go board 9x9. Use this to drive quad bounds
    for the 9x9 board, and the grid.

    Rotated go board texture 90 degrees so the grain is in the
    correct direction -- top to bottom along the long axis!


Added shadows (29/4/2013):
--------------------------

    Implement shadow shader

    Fixed problems with backface culling

    Render shadow with simple z=0 collapse

    Make sure shadow renders with proper alpha 
    and does not z-fight against the board quad.

    Render both stone and shadow

    Work out how to correctly project stone onto ground plane

    Tune the light location so the result looks OK on the side

    Tuned the shadow for iPhone

    Seems that we *absolutely* need to fade the shadow alpha out
    as the stone moves away from the board. It must be zero alpha
    but the time the stone gets near the light point


Added go board background texture (29/4/2013):
----------------------------------------------

    Load separate shaders for board and stone

    Switch between shaders ready for rendering

    Sketch out code to render the quad using vert buffer

    Learn how to feed in texture coordinates via vertex buffer

    Why is the stone still dropped from height? It should be spawned
    at position (0,0,0). I cannot see what is causing this?!

    Fixed. The stone was not being dropped. The smooth zoom
    was initialized to 0 which meant that it "pulled back" away
    from the stone on startup, making it look like the stone
    was falling.

    Switch to static vertex buffer for board

    Get the board texture rendered on the quad

    Tune the board quad dimensions and texture density

    Debug why weird stuff happens with uniform normal matrix on
    the go stone when I have multiple shader programs.

    Fixed. Uniforms were not being properly split across
    different programs, eg. the uniform for the stone shader
    was discarded when I loaded board shader.

    Fixed by having a separate array of uniforms for the stone
    and board shaders.


Small impulse applied when you touch the stone (28/4/2013):
-----------------------------------------------------------

    Apply a light impulse along the camera ray when first selecting a stone

    This way you can tap stones and they will react by wobbling,
    depending on where on the stone you touched.

    In practice this looks quite realistic!


Detected more complicated checkpoints (28/4/2013):
--------------------------------------------------

    Detect at rest on each plane

    Detect sliding on each plane

    Tuned flick vs. drag threshold

    Detect spinning on each plane

    Detect various device orientations:

     - perfectly flat
     - neutral (nearly flat)
     - left, right, up, down
     - upside down


Added testflight checkpoints for common interactions (27/4/2013):
-----------------------------------------------------------------

     - zoomed in
     - zoomed out
     - applied impulse
     - selected stone
     - dragged stone
     - flicked stone
     - tapped stone
     - bounced off near plane


Setup testflight, got a few beta testers (18/4/2013):
-----------------------------------------------------

    Get icon ready

    Integrate with testflight SDK and start distributing to testers

    Send Test flight invites to:

     - Paul Bragiel
     - Mark McCubbin
     - Dave Taylor
     - Morgan
     - Matt Ditton
     - Dave Jaffe
     - Go Game Guru
     - Thomas Rizos
     - Rex Guo

    Invite URL is http://tflig.ht/ZvH5xr

    Apparently I need to collect all their devices, then 
    make a build adding these devices to my provisioning
    profile.

    This is problematic as this profile seems to have max 99 devices?!


Fixed bug in select and drag, handle multi-touch (16/4/2013):
-------------------------------------------------------------

    Ray vs. plane intersection was not properly handling
    plane d, leading to the intersection being a mirror
    plane, rather than the intended plane.

    This manifested as popping and strange perspective 
    artifacts in stone select and drag.

    Cancel swipe/hold if multiple touches occur.

    Swipe is one finger only!

    Drag is one finger only!


Tweak launch (15/4/2013):
-------------------------

    Previously the launch only worked in the up direction

    I've changed it so that any jerk > 0.5 will launch in
    that direction.

    When you shake or move the iPhone about it now looks
    quite cool, like the stone is shaking about in there.

    The cost is that accidental bumps can move the stone
    a lot more than intended along the playing surface.


Drag stone (15/4/2013):
-----------------------

    Click and hold damps the stone rotation

    Detect click intersect with stone. Go into "select" mode

    While in select mode damp the stone rotation. Don't apply gravity.

    Calculate xy offset from stone center on first intersection,
    and depth of intersection z.

    Then intersect ray with that plane and calculate stone center
    using offset.

    Somehow this gives a perspective effect that is unpleasant.

    To fix I need to implement the offsetting in screen coords?

    Inherit velocity on stone release. Feels really good!


Spin on swipe (15/4/2013):
---------------------------

    Determine start and endpoint of swipe in screen space

    Determine swipe time in seconds

    Call a handler function with the data

    It seems that swipe time varies a lot for swipes
    that seem otherwise simular.

    This indicates that calculating exact "swipe velocity" is 
    probably not a good idea with the current setup. 

    This is because the velocity counts the start and end points, 
    and therefore includes any hold time before the swipe is fired
    off.

    But for now, I'm going to just assume that the only thing 
    I can extract is the start point and the swipe delta in
    screen space. Lets work with that!

    Convert swipe start point to a ray.

    Intersect this ray with a plane with normal +z
    through the center of the go stone.

    To calculate the direction of the angular moment, take the cross
    product of the swipe direction * swipe momentum constant and
    apply it as if applying angular part of velocity at a point.

    OK I tried all of this and it sucks.

    The solution is that on any swipe I apply an angular impulse
    around the up vector. This works well and is as simple as
    possible!


Swipe detection (15/4/2013):
----------------------------

    Simple built in swipe gesture does not provide starting point of swipe

    It is just one of four directions: left/right/up/down

    This is fine for flipping pages and so on, but it does not
    suit my needs. I need to know where the swipe is relative
    to the go stone, so I can work out the axis of rotation!

    It would seem that the smartest thing to do would be to detect
    a press down then set a flag then if a release is detected
    a certain distance away and within a certain time then this
    is a swipe.

    This gives me a direction of the start and end points of the swipe.

    Cancel swipe if it goes on too long, eg. 1 second


More iOS demo app tuning (15/4/2013):
-------------------------------------

    Home sick with a sore back :(

    Clamp z coordinate to be no larger than smoothZoom 
    (stop the stone rolling back behind your eye... !!!)

    Implement code to detect launching the stone up. WOW!

    If stone is just dropped and above frustum clamp velocity 
    so it cannot have z into the eye. 

    This stop the stone "sticking" when released holding the 
    phone upside down.


Work on iOS app (14/4/2013):
----------------------------

    Get basic stone physics into iOS app

    Get basic collision working with floor

    Hook up gravity to be driven by the accelerometer

    *** WOW!!! ***

    Tune elasticity and friction

    Add the jerk acceleration to the stone

    Adjusted to size 40 stone as it has a cool lazy wobble!

    Add collision planes for walls. Include, near, far and side planes.

    If the stone is within bounding sphere radius of near plane
    snap position to center - eye position axis

    If stone is close to the eye clear screen white

    Fix up code to get correct frustrum planes

    *** WOW!!! ***


Various post-GDC fixes (14/4/2013):
-----------------------------------

    Convert to right handed coordinates (WIP fixing up)

    Fixed biconvex support

    Fixed weirdness with camera zoom levels

    Fixed stone strafe sliding directions

    Contact point is wrong with biconvex vs. primary surface

    Re-enable energy kinetic energy post-collision test. Works with epsilon!

    Fix lighting in collision demo

    Remove VirtualGo.cpp demo -- too similar to collision demo

    Tessellation demo appears to be inside out?

    Why are cracks showing in tessellation demo? Not any more!

    Find a way to unify code between xcode and sublime codebases


Ported stone demo to iPad/iPhone (14/4/2013):
---------------------------------------------

    Simple OpenGL rendering with OpenGL ES 2.0

    Detected single tap vs. double tap

    Detected application wake up / sleep

    Disabled different orientations in app

    Read accelerometer value, lowpass to find gravity
    then take the highpass to detect acceleration jerks

    Determine appropriate zoom level for iPhone vs. iPad so the
    go stone at zoomed out mode is actual size, and in zoomed in
    mode does not clip against the screen bounds.


Separated collision demo, added video recording (17/3/2013):
------------------------------------------------------------

    Separate collision demo

    Add video capture to collision demo

    Add mode where go stone sticks on the board after push out

    Add mode where go stone penetrates the board and freezes

    Render contact point and normal in push out mode in red


Added video recording to support demo (17/3/2013):
--------------------------------------------------

    You can now record video from the support demo

    This gives a good visual demonstration of biconvex support
    witha rotating go stone projecting its bounds onto an axis
    with an orthographic projection.


Added dynamics demo and captured videos for article (16/3/2013):
----------------------------------------------------------------

    Add dynamics demo with:

        1. linear strobe once per-second
        2. linear smooth movement
        3. gravity
        4. angular motion
        5. combination linear and angular motion with gravity

    Add some way to get the strobe remember rigid body snapshots
    and render those. Snapshots should be taken every n seconds,
    where the accumulator is per-mode.

    Snapshots and accumulator should be cleared on mode change

    Tune the snapshots so they record good video / diagrams

    Demo record inputs and playback with video capture

    Capture all videos required for "How The Go Stone Moves"
    and upload to youtube.com

    Urgh. the video quality! =p


Fixed cracks in tesselation (7/3/2012):
---------------------------------------

    Epsilon was set too low when merging vertices, leading to 
    the normals of circle edge not matching with the normals
    of the biconvex, presumably leaving T-joins in the mesh
    between the sphere surface and the bevel torus.

    Increasing the epsilon value from 0.001 to 0.01 cms fixed
    the issue. Easy!

    This value should still be small enough to avoid any overly 
    aggressive vertex welds.


Fixed the damping decay factor so it is framerate independent (7/3/2012):
-------------------------------------------------------------------------

    With a simple adjustment using exponent it is verified to have the
    same amount of damping in super slow-motion as it does when the
    game is running full speed.

    This should also work for adjustments to the number of substep
    iterations in the physics engine as well (this adjusts the dt)


Applied black wood texture to go board (6/3/2012):
--------------------------------------------------

    The black texture looks particularly good with the 
    murasaki go stones!

    I think I'll take this to GDC as my demo.


Applied murasaki texture to go stone (6/3/2013):
------------------------------------------------

    Fixed the lights on the stone to look a lot better

    Create a new mode "Textured" (5)

    Integrate stb_image and load murasaki.jpg

    Create opengl texture objects

    Extend the tesselator so that it generates UV coordinates

    Extend the mesh render so it emits texture UVs

    Improve the lighting on the board

    Render the background as dark grey so black stones
    have some chance of being visible :)

    Work out why the fuck the texture is not showing up

    glGenerateMipmap :)

    Enabled anisotropic filtering

    Enabled trilinear filtering

    Apply murasaki texture to the go stone


Applied hacked damping and rolling/spinning friction (5/3/2013):
----------------------------------------------------------------

    The actual spinning/rolling friction specified in this paper
    is quite complicated and most likely overkill.

    http://physbam.stanford.edu/~fedkiw/papers/stanford2003-01.pdf

    Although it would be very nice to explore in the future,
    for now I've just created a hack with a variable amount 
    of damping propertional to the angualar velocity length.

    The trick was to have two values of damping while in contact
    a low damping value while angular rotation is large, and a
    smaller value for when angular rotation is small.

    To make the transition between these two values less obvious
    I added some interpolation between a transition angvel length
    range.

    This hack gives a reasonable approximation of what I want

     1. good coin spinning type movement
     2. rapid settling once the coin spin motion collapses
     3. good natural looking wobbles when coming to rest for all stones sizes

    So simple and works so good it should be a crime! :)


Fixed wireframe view, provide stone drop type selection (5/3/2013):
-------------------------------------------------------------------

    Fix the wireframe view, it's all broken with z-testing again

    Provide some way to select between initial stone drop conditions,
    
    eg:

        F1 = flat, 
        F2 = 45 degrees
        F3 = vertical
        F4 = 45 degrees more
        F5 = random orientation
        F6 = random orientation with spin


Finished edge and corner cases (5/3/2013):
------------------------------------------

    It is difficult to tell 100% but it seems that the stone is not
    colliding perfectly with the edge, but has some separation out
    from the edge -- sliding the stone off the edge then zooming in
    should help determine if this is actually happening

    No, it is working fine as shone by sliding the stone up onto the 
    side edge from off the board, it lines up perfectly.

    Need another key mapping for zoom level now that I'm using CTRL
    left/right/up/down to apply a linear impulse to the stone.

    Hacked it in, now zoom level is ALT-CTRL+UP/DOWN (shoot me)

    Implement the remaining side cases

    Implement bottom left corner case

    Bottom right corner

    Top left corner

    Top right corner


Work on left edge side for board (5/3/2013):
--------------------------------------------

    Implemented function to get nearest point on line and biconvex

    This will be used for the left edge

    Implemented the top and left side cases for the biconvex nearest
    point to the board, seem to be working OK.

    The plan for left side is as follows:

        1. Test the primary plane, but ignore if point is outside bounds
        2. Test the side plane, but ignore if point is outside bounds
        3. Test the edge, by definition cannot be outside bounds

    So far the first two cases are implemented and seem to be working

    Next I am hooking up the left side edge case

    Once this is done it should be relatively easy to generalize
    to all edges, eg. break up into a function so there is not
    a lot of cut & paste.

    Integrate nearest point on left edge case

    Visualized nearest point between stone and board. Seems to be working

    Why is the collision response suspect when hitting the side edge?

    Could it be that the normal is slightly incorrect?

    Should the normal be on the biconvex surface instead of the edge
    normal, is this what is wrong?!

    Found it: the nearest point on biconvex vs. line function was wrong

    Reworking the function so that it considers the sphere and the
    circle edge cases properly, and takes the closest point to the 
    line.

    There appears to be one final broken case now. Perhaps it is a fuckup
    with the top sphere vs. the bottom sphere? YES! It was!

    Need to be able to slide the stone off the edge

    Implemented this by adding linear impulse on CTRL + LEFT/RIGHT/UP/DOWN


Go board now has correct dimensions (4/3/2013):
-----------------------------------------------

    Find exact measurements of standard go board dimensions

    Parameterized board by the size (eg: 9, 13, 19), with the height
    of grid cells being slightly larger than the width (japanese style)

    Determine how much border there is for a standard japanese board (15mm)

    Separate the grid rendering from the rendering of the board

    Can now select board size on the fly:

        ALT-1: 9x9
        ALT-2: 13x13
        ALT-3: 19x19

    You can crash the demo if you increase the rotation too much with W
    so I added a clamp to maximum rotational inertia for any rigid body


Polish and new demo features (3/3/2013):
----------------------------------------

    Holding down tab scrolls to focus on the current stone

    If you hold down tab while the stone is moving, the camera 
    roughly tracks the stone

    Fixed the lighting

    Added a small impulse if the go stone is inside the go board
    at the beginning of the frame. This gives a cool trampoline effect
    when you adjust teh size of the go board on the fly.

    You now can add angular velocity with QWE and remove it with R


Lots of work on the GDC 2013 talk demo (2/3/2013):
--------------------------------------------------

    Remove the "Picking" demo as it is visually uninteresting

    Can now globally adjust go stone size via alt+left/right

    Added camera zoom levels driven by up/down 

    Make the go board have a center which is the grid point, not the 
    grid center. Asthetically any go player will find it strange otherwise
    (I do)

    Calculating the inertia tensor is too slow. Worked around with less precision

    Escape now restores defaults. For the moment this is just stone size 34

    Enter now drops a stone in the current mode

    Can now select side views in the board demo. 

    When dropping a stone in side view it drops exactly on the edge

    When switching to non-board views the view selection is reset to center

    Camera movement is now relative to the top of the board so it doesn't
    need to be adjusted for different height boards

    Can now adjust board height via ALT-UP/DOWN

    Switched zoom should be control-UP/DOWN because I need UP/DOWN for
    Z selection on the board, eg. ability to select center, sides and corners.

    Adjusted camera and lighting so +Z is forward into the screen when looking
    down the board side-on. Previously it was hacked up with +X into the screen

    The user can now scroll smoothly along the board with left/right/up/down

    Scrolling feels good now and is no longer limited to the small board

    Added more smoothing for the camera tween and now the view adjustments
    feel less jarring and acceptable. Still would be nicer for them to be
    ore analog than discrete, but it is "good enough" for the moment.

    Switch to the large board by default. Small/large board split removed.

    Demo initially does nothing (black screen) until user selects a demo

    Stone is now properly hidden when behind the board

    Can now scroll up/down in Y axis with A/Z. Height is clamped to
    not go below the top surface of the board.


Work on collision response with board (24/2/2013):
--------------------------------------------------

    Split out collision response into separate functions

    Update collision demo to use collision response functions

    Simplify collision detection with the board into a function
    that detects collision, does the projection out of the board
    and returns a static contact point.

    Collide first with the board then with the floor

    Implement collision detection with the floor and do it in
    the same form, eg. detect collision, perform the projection
    and return a static contact point.

    Adjust the board to have thickness and change it from the
    y=0 plane on the top. Floor should be y = 0, board is above

    Verify everything is working, eg. try a really small board

    Implement a function to render the board


Fixed energy being added by friction impulse (19/2/2013):
---------------------------------------------------------

    Was calculating tangent impulse based on velocity at point
    *before* applying normal impulse.

    In some cases this was adding energy to the system.

    Recalculating velocity at a point post-normal impulse and
    using this in the tangent impulse calculation stopped the
    energy from being added.
    

Switched from linear/angular velocity to momentum (18/2/2013):
--------------------------------------------------------------

    Previous code was using linear/angular velocity as the primary
    quantity.

    Switch to using momentum as primary and calculating linear
    and angular velocity from it as secondary quantities.

    Also fixed an error in the rotational kinetic energy calculation.

    Unfortunately, it still seems that coulomb friction impulse
    is adding energy to the system :(


Work on GDC 2013 talk (14/1/2013):
----------------------------------

    Plan out talk slides

    Determine the set of diagrams and demos that remain to be done

    Create first passes of the diagrams on pen and paper

    Work out what demo sections/visualizations are required

    Break up demo visualizations into separate demos that can
    be run and controlled via keyboard.


Finished tesselation demo (5/1/2013):
-------------------------------------

    Find a way to interpret 0-5 in the naive biconvex render
    so the naive tesselation changes with left/right as wall.

    Add a render mode to tesselation to view the stone
    not in wireframe. Ideally, this would be textured
    as well with better lighting but that can wait!


Properly weld bevel to biconvex at various tesselation levels (4/1/2013):
-------------------------------------------------------------------------

    left/right: adjust tesselation depth, 1 to maximum 5

    Find the vertices at the bottom edge of the biconvex top 
    and sort according to angle around the +y axis

    Next use these vertices as the start vertices for the bevel

    Finally, make the bevel # of rings be determined by the angle
    between the start and finish bevel, this way it should tesselate
    uniformly for various sizes of bevel.


Tesselated bevel torus + implement vertex welding (4/1/2013):
-------------------------------------------------------------

    Tesselate the bevel torus with quads.

    Create vertex buffer structure with normals

    vec3f position
    vec3f normal

    Sketch out interface to build mesh

    Implement grid cell -> hash bucket function

    Determine grid cell for vertex (x,y,z)

    Search in the bucket for a vertex with close enough position *and* normal!

    Add code to insert vertex into bucket if doesn't already exist (eg. push back on list)

    Verify that vertices have actually been welded (eg. print out per-weld w. static counter)

    If vertex is being added within epsilon of another grid cell,
    insert the index to that vertex in the other grid cell as well.

    Without vertex welding:

        18432 triangles
        55296 vertices
        55296 indices

    With vertex welding:

        18432 triangles
        9636 vertices
        55296 indices    

    With vertex welding + non-diagonal adjacent cells:

        18432 triangles
        9570 vertices       <--- correct! it is less!
        55296 indices

    With vertex welding + all adjacent cells (including diagonals):

        18432 triangles
        9570 vertices
        55296 indices


Calculated bevel torus for biconvex stone (3/1/2013):
-----------------------------------------------------

    Determine how to mathematically define the ideal
    torus for the smooth edge on the biconvex solid.

    The input should be the height of the bevel,
    this can then be used to determine the tangent
    at the edge of the sphere

    Knowing the tangent at the edge it should be 
    possible to determine the major and minor radii
    of the torus.


Improved stone tesselation added lighting etc. (1/1/2013):
----------------------------------------------------------

    Render the stone with gouraud shading

    Enable anti-aliasing

    Integrate GNU Tesselation Library
    http://gts.sourceforge.net/index.html

    Recover code from original Virtual Go that performed
    the tesselation of the go stone via GTS.

    Code is crap. Discarded.

    Subdivide the spherical cap by starting with a n-gon shape
    projected on to the sphere, and subdividing the triangles
    in the hexagon shape and projecting out to the sphere.

    5-gon seems to give best result (triangles close to equilateral)

    Generate the bottom of the biconvex

    Split up the code into headers to make it easier to manage


Solved strange energy adding effects (9/9/2012):
------------------------------------------------

    Reworked the collision response from scratch and verified 
    that no additional energy is added.


Calculated volume of biconvex solid (3/9/2012):
-----------------------------------------------

    Write a function to calculate the volume of the stone
    given biconvex width and height

    This means I'll need to do an integral for sphere volume
    but only for the top bit and bottom bits of the sphere

    Measure how much the stone weighs in real life

    Determine approximately what the density of the stone
    is, this will allow me to calculate the inertia tensor
    via the numerical integration

    Fixed a bug where linear impulse was not being scaled
    by inverse mass. This is explains the strange behavior
    that was occuring with different mass values.
    

Numerically integrated inertia tensor for biconvex solid (3/9/2012):
--------------------------------------------------------------------

    The inertia tensor is the sum of all moments (r^2*point mass)

    So I just iterated across the xyz bounds and summed up the
    moments numerically. This gives me an approximation for the
    inertia tensor which is pretty sweet.

    It seems that the ratio of the inertia tensor to the mass,
    or the *closeness* of it to 1.0 elements is quite important
    for the stability of the simulation.

    It would seem really that the only thing that matters is
    the ratio between the xz and the y inertia tensor, and (possibly)
    the ratio between the mass and the inertia tensor values

    But linear mass is probably irrelevent in the collision between
    stone and board, since the board is treated as having infinite
    mass.

    It would only kick in when I do stone vs. stone collision?

    No. I think it matters because the mass is an input to the
    collision response even vs. the board. Should study the effect
    that the ratio of the mass vs. the inertia tensor values has


Switched to ellipsoid inertia tensor (2/9/2012):
------------------------------------------------

    Write function for inertia tensor of a sphere given radius/mass

    Write function for inertia tensor of an ellipsoid    

    Retuned simulation based around inertia tensor given
    an ellipsoid with axes (1,0.5,1), which isn't EXACT
    but it's pretty damn close!


Switch to left handed coordinate system (2/9/2012):
---------------------------------------------------

    There is something wrong with my angular velocity math
    or with my velocity at point function, because I have
    had to explicitly invert the quaternion -> matrix
    conversion, and negate the angular impulse

    OpenGL coordinate system is right handed.

    Thought it was left handed. Switched!

    Verified that quat -> matrix needs transpose,
    otherwise rotation is in the opposite direction
    to what I expect.

    Verified that angular velocity is integrating properly
    eg. angular velocity of (0,0,20) rotates counter-clockwise
    around the z axis (positive direction, left handed rule)

    So then where is the inversion?

    It would SEEM that it must be inside my impulse calculation
    or in my velocity at point on rigid body function, because
    the angular velocity integration is working properly!


Implemented normal impulse and coulomb friction impulse (27/8/2012):
--------------------------------------------------------------------

    Calculate impulse as per-wikipedia entry formala
    for restitution:

    http://en.wikipedia.org/wiki/Collision_response

    Applied friction impulse from Erin's GDC tutorial


Aborted POI approach. I misunderstood speculative contacts! (21/8/2012):
------------------------------------------------------------------------

    There is some very strange problem with the collision
    response. It appears to get "stuck" often, indicating
    that the bisection is not 100% correct?

    My guess would be that the bisection is incorrectly
    thinking that the stone is moving towards the board
    and stopping dt advancement

    The collision response is not properly implementing
    the sort of sliding behavior I am looking for if a stone
    slides down on a surface edge it should slide out.

    It seems that my understanding of speculative contacts
    was entirely incorrect. It seems I am implementing
    something different, also I do not understand how
    rolling and sliding contacts work within speculative
    contacts...


Really crappy collision response + friction (19/8/2012):
--------------------------------------------------------

    Added a small amount of damping to linear and angular
    velocity so the system does not explode.

    Also added a totally bullshit friction impulse to the
    collision response so the impulse is not purely in the
    plane normal direction (the stone tumbles around)


First pass collision response (19/8/2012):
------------------------------------------

    Need a function to determine rigid body velocity at point

    Need a function to apply an impulse at a point

    Add a new demo for collision response (7)

    Perform collision response such that an impulse is applied
    that removes the velocity *into* the plane surface at the
    point of collision.


Added function to determine closest features on board and stone (18/8/2012):
----------------------------------------------------------------------------

    Now we need a function that gives us the closest point
    on the biconvex to the plane.

    Basically, we want to ask the question -- what is the 
    closest (or deepest) point on the biconvex re. the plane,
    and then we want to project this point onto the plane surface

    The logic on this should be similar to finding the point
    that is projected onto the axis for the SAT, eg. this 
    would be the point that becomes projected s1

    The normal should always be directly up.

    Extended function so that it returns separate points and normals
    on the stone and on the board, eg:

        stonePoint
        stoneNormal
        boardPoint
        boardNormal

    Visualized board point+normal as red line, and stone point+normal
    as yellow line. Verified that they are working properly.

    Worked around a problem with transforming a plane, the W coordinate
    was not being correctly transformed. Slow workaround function is 
    working properly in the interim.


Bisect to find point of stone/board collision (18/8/2012):
----------------------------------------------------------

    Bisect to find exact point of collision

    The stone moves so fast that it tunnels inside the plane
    when it falls from a height.

    Fix this by subdividing the step searching for the first
    time where the stone collides with the board.

    Freeze the stone at this time and verify visually
    that it is not penetrating with ortho projection.


Stone board collision test now uses SAT (18/8/2012):
----------------------------------------------------

    Convert stone vs. board intersection test to use SAT
    instead of using exact point/normal plane test w. biconvex

    We only care about the binary result we do not want the 
    collision point and normal.


Added bisection demo in ortho projection (9/8/2012):
----------------------------------------------------

    Now I can see the result of the collision and determ whether
    any penetration into the plane surface exists.

    Next step, implement the bisection!


Simple collision detection between stone and board (8/8/2012):
--------------------------------------------------------------

    Implement collision detection between stone and board

    First I just need a boolean function that just says:

        Stone vs. Board intersecting? (true/false)

    When the stone has collided, detect this and freeze it
    in place so it does not move until "space" is pressed.


Angular motion for stone (8/8/2012):
------------------------------------

    Bring back quaternion class

    Implement simple integration of angular velocity -> quat delta (spin)

    Convert position/quaternion combo to rigid body matrix

    Stone should now tumble as it falls

    Randomize initial stone angular velocity


First pass stone kinematics (7/8/2012):
---------------------------------------

    Added a new demo that shows a falling stone with linear motion only

    Stone falls under gravity and passes right through the board


Visualize nearest point on biconvex function (7/8/2012):
--------------------------------------------------------

    When ray is not hitting stone, draw a yellow line between
    the intersection with the plane and the nearest point on
    the biconvex surface.

    This will let me verify that the nearest point on biconvex
    relative to another point is correct -- the point will always
    by definition be *outside* the biconvex, otherwise the pick ray
    would have hit the biconvex stone first.


Implement ray vs. board intersection (7/8/2012):
------------------------------------------------

    Implement ray vs. plane intersection

    Implement ray vs. board intersection 
    (for the moment, just test the primary surface and verify
     that the ray hit is within width/height bounds on plane...)

    Detect whether ray is hitting board or stones via t

    Show normal when hitting board


Visualized biconvex support along x-axis (6/8/2012):
----------------------------------------------------

    The dot threshold was incorrect. Was 1-sphereDot,
    but sphereDot was the correct value.

    When looking at biconvex circle span with ortho projection
    it appears to be correct. The perspective was throwing it
    off!

    Biconvex support now looks visually correct!


Visualized stone + board (6/8/2012):
------------------------------------

    Visualize stone vs. board intersection with blue line
    from point out along normal

    Stone vs. board intersection point appears to be incorrect
    when the sphere surface is nearest to the plane.

    Fixed calculation for sphere surface intersection point.


Render stone + board (5/8/2012):
--------------------------------

    Find some way to switch between modes

        eg. 1 = rotating stone
            2 = stone + board

    Zoom out to show the stone from a distance without rotation

    Render the board in wireframe according to dimensions and some
    tesselation factor

    Now render the board and the stone in the same app


Implemented mouse picking (5/8/2012):
-------------------------------------

    Intersect ray with biconvex and render point and normal
    of intersection if exists.

    Don't hide the mouse

    Space toggles rotation of the stone

    Add function to get mouse xy coordinates 

    Turn mouse xy into pick ray
    http://stackoverflow.com/questions/2093096/implementing-ray-picking

    Verify that intersection under mouse *LOOKS* correct


Render go stone as quads (5/8/2012):
------------------------------------

    Extend go stone render to render in quad strips + triangle
    strips for top section.

    Render quads in wireframe

    Render quads in wireframe with backface culling


Render go stone in wireframe (5/8/2012):
----------------------------------------

    It should be reasonably easy to render a wireframe
    go stone at the origin, pick a # of segments, then
    radially rotate about the origin and draw

    Then extend this to support a rigid body transform
    for the go stone and render it with that

    Next, allow the go stone to rotate about an axis
    and visualize the intersection point and normal with
    the board in wireframe


Implemented stone vs. board primary surface case (4/8/2012):
------------------------------------------------------------

    To handle intersection between biconvex stone and plane:

        1. transform plane into biconvex local space
        2. determine intersection in local space (done)
        3. if intersecting, transform point/normal into world space

    Unit tested simple case at origin with no rotation.

    Unit tested translated away from origin with no rotation.

    Unit tested rotated 180 degrees at origin (upside down)

    Unit tested rotated 180 degrees away from origin.

    Unit tested +/- 90 degrees rotation cases away from origin 
    (circle edge of biconvex solid)

    I can now be confident that the local to world / world to 
    local, transform plane, transform point, transform normal
    fns are all working correctly.


Rigid Body Transform (2/8/2012)
-------------------------------

    Added "RigidBodyTransform" class with cached local -> world,
    and world -> local transforms.

    Added helper function to get world position from transform.

    Implemented rigid body transform inverse, eg. world -> local.


Added board class and stone vs. board collision type test (1/8/2012)
--------------------------------------------------------------------

    Added stone class with dimensions width, height and thickness.

    Categorized stone vs. board collision into cases, eg. primary
    surface, no collision, left edge, top-right corner etc.

    Sketched out stone vs. board collision test function logic

    Unit tested the board collision type function.


Implemented Biconvex vs. Biconvex SAT test (26/7/2012)
------------------------------------------------------

    Write function to determine projection of biconvex onto a line.

    Implement basic unit tests of the span across xyz axes

    Determine set of axes to test one biconvex vs. another. 
    I believe if it is all combinations of lines between sphere
    centers, and a line from the center of each biconvex through
    the circle plane, to the projection of the other biconvex center
    onto the circle plane. YES!

    Write a function that determines the projection of a biconvex
    with a rigid body transform onto a line. This will be used for
    determining the projection of the "other" biconvex.

    Implement a biconvex vs. biconvex SAT function which accepts
    world space position/up per-biconvex and returns true if they
    are intersecting.


Basic OpenGL display (24/7/2012):
---------------------------------

    Link to OpenGL, Carbon etc from premake

    Get a fullscreen opengl display going (bring in from "Cube" demo...)


Added intersection and collision functions for biconvex solid (22/8/2012)
-------------------------------------------------------------------------

    Restore basic biconvex class with math to determine sphere radius
    and offset for a given biconvex width and height.

    Get the vector library back up and running from scoopr. 
    Don't resurrect my own crappy library that isn't SIMD!!!

    Copy across useful code from old biconvex mathematics
    routines, eg. 

        0. ray vs. sphere
        1. ray vs. biconvex (local space)

    Quick test to determine if a point is inside the biconvex.

    Add a function to determine if a point is on the biconvex surface within epsilon.

    Determine normal given a point on the biconvex surface.
    This should accept an epsilon in which it determines that the point is on
    the circle edge, vs. being on the sphere edge. In the case of circle edge
    express the normal as outwards from the circle.

    Find closest point on biconvex to another point (point is outside the biconvex)

    This breaks down into:

        a) closest point on sphere -- easy
        b) closest point on circle -- project to xz plane, normalize and multiply by circle radius

    Determine dot at edge of biconvex (eg. within which the plane collision 
    will be a collision with the circle, not the sphere surface...)

    This angle can be determined by looking at the origin of one of the generating
    spheres, and determining the angle between the x axis, and the line to the side
    of the biconvex shape.

    Use this to rework the plane collision to determine the dot range
    in which the plane must collide with the circle, and not the sphere
    surfaces.

    Add tests for top, buttom and edge cases of biconvex vs. plane

    Fix the function so that the results are what we expect!

    Rework function so we get information about nearest point even
    if the plane and biconvex are not colliding yet.

    Get unit testing framework integrated into the project

    Convert all printf tests over to unit tests.

    Problem with nearest point on biconvex surface, it is giving NaNs
    for trivial points outside the biconvex, eg. (0,10,0) above the 
    biconvex should result in (0,0.5,0)

    Convert plane biconvex intersection. Make sure all three cases
    are properly tested:

        1. top surface
        2. sphere surface
        3. circle edge
    
    I still want a "pm dev" console app that I can use to just printf
    and explore various things, as well as "pm test" and "pm go" for
    the actual opengl program.

    For the moment the quickest way to get all this stuff going is to
    just have it all in VirtualGo.cpp. Over structuring is a waste of 
    my time.

    So to get this working have VIRTUALGO_TEST, VIRTUALGO_CONSOLE
    defined with separate behavior for these guys, and default
    is to run the real program (eg. "pm go")
