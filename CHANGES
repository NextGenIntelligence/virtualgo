

Angular motion for stone (8/8/2012):
------------------------------------

    Bring back quaternion class

    Implement simple integration of angular velocity -> quat delta (spin)

    Convert position/quaternion combo to rigid body matrix

    Stone should now tumble as it falls

    Randomize initial stone angular velocity


First pass stone kinematics (7/8/2012):
---------------------------------------

    Added a new demo that shows a falling stone with linear motion only

    Stone falls under gravity and passes right through the board


Visualize nearest point on biconvex function (7/8/2012):
--------------------------------------------------------

    When ray is not hitting stone, draw a yellow line between
    the intersection with the plane and the nearest point on
    the biconvex surface.

    This will let me verify that the nearest point on biconvex
    relative to another point is correct -- the point will always
    by definition be *outside* the biconvex, otherwise the pick ray
    would have hit the biconvex stone first.


Implement ray vs. board intersection (7/8/2012):
------------------------------------------------

    Implement ray vs. plane intersection

    Implement ray vs. board intersection 
    (for the moment, just test the primary surface and verify
     that the ray hit is within width/height bounds on plane...)

    Detect whether ray is hitting board or stones via t

    Show normal when hitting board


Visualized biconvex support along x-axis (6/8/2012):
----------------------------------------------------

    The dot threshold was incorrect. Was 1-sphereDot,
    but sphereDot was the correct value.

    When looking at biconvex circle span with ortho projection
    it appears to be correct. The perspective was throwing it
    off!

    Biconvex support now looks visually correct!


Visualized stone + board (6/8/2012):
------------------------------------

    Visualize stone vs. board intersection with blue line
    from point out along normal

    Stone vs. board intersection point appears to be incorrect
    when the sphere surface is nearest to the plane.

    Fixed calculation for sphere surface intersection point.


Render stone + board (5/8/2012):
--------------------------------

    Find some way to switch between modes

        eg. 1 = rotating stone
            2 = stone + board

    Zoom out to show the stone from a distance without rotation

    Render the board in wireframe according to dimensions and some
    tesselation factor

    Now render the board and the stone in the same app


Implemented mouse picking (5/8/2012):
-------------------------------------

    Intersect ray with biconvex and render point and normal
    of intersection if exists.

    Don't hide the mouse

    Space toggles rotation of the stone

    Add function to get mouse xy coordinates 

    Turn mouse xy into pick ray
    http://stackoverflow.com/questions/2093096/implementing-ray-picking

    Verify that intersection under mouse *LOOKS* correct


Render go stone as quads (5/8/2012):
------------------------------------

    Extend go stone render to render in quad strips + triangle
    strips for top section.

    Render quads in wireframe

    Render quads in wireframe with backface culling


Render go stone in wireframe (5/8/2012):
----------------------------------------

    It should be reasonably easy to render a wireframe
    go stone at the origin, pick a # of segments, then
    radially rotate about the origin and draw

    Then extend this to support a rigid body transform
    for the go stone and render it with that

    Next, allow the go stone to rotate about an axis
    and visualize the intersection point and normal with
    the board in wireframe


Implemented stone vs. board primary surface case (4/8/2012):
------------------------------------------------------------

    To handle intersection between biconvex stone and plane:

        1. transform plane into biconvex local space
        2. determine intersection in local space (done)
        3. if intersecting, transform point/normal into world space

    Unit tested simple case at origin with no rotation.

    Unit tested translated away from origin with no rotation.

    Unit tested rotated 180 degrees at origin (upside down)

    Unit tested rotated 180 degrees away from origin.

    Unit tested +/- 90 degrees rotation cases away from origin 
    (circle edge of biconvex solid)

    I can now be confident that the local to world / world to 
    local, transform plane, transform point, transform normal
    fns are all working correctly.


Rigid Body Transform (2/8/2012)
-------------------------------

    Added "RigidBodyTransform" class with cached local -> world,
    and world -> local transforms.

    Added helper function to get world position from transform.

    Implemented rigid body transform inverse, eg. world -> local.


Added board class and stone vs. board collision type test (1/8/2012)
--------------------------------------------------------------------

    Added stone class with dimensions width, height and thickness.

    Categorized stone vs. board collision into cases, eg. primary
    surface, no collision, left edge, top-right corner etc.

    Sketched out stone vs. board collision test function logic

    Unit tested the board collision type function.


Implemented Biconvex vs. Biconvex SAT test (26/7/2012)
------------------------------------------------------

    Write function to determine projection of biconvex onto a line.

    Implement basic unit tests of the span across xyz axes

    Determine set of axes to test one biconvex vs. another. 
    I believe if it is all combinations of lines between sphere
    centers, and a line from the center of each biconvex through
    the circle plane, to the projection of the other biconvex center
    onto the circle plane. YES!

    Write a function that determines the projection of a biconvex
    with a rigid body transform onto a line. This will be used for
    determining the projection of the "other" biconvex.

    Implement a biconvex vs. biconvex SAT function which accepts
    world space position/up per-biconvex and returns true if they
    are intersecting.


Basic OpenGL display (24/7/2012):
---------------------------------

    Link to OpenGL, Carbon etc from premake

    Get a fullscreen opengl display going (bring in from "Cube" demo...)


Added intersection and collision functions for biconvex solid (22/8/2012)
-------------------------------------------------------------------------

    Restore basic biconvex class with math to determine sphere radius
    and offset for a given biconvex width and height.

    Get the vector library back up and running from scoopr. 
    Don't resurrect my own crappy library that isn't SIMD!!!

    Copy across useful code from old biconvex mathematics
    routines, eg. 

        0. ray vs. sphere
        1. ray vs. biconvex (local space)

    Quick test to determine if a point is inside the biconvex.

    Add a function to determine if a point is on the biconvex surface within epsilon.

    Determine normal given a point on the biconvex surface.
    This should accept an epsilon in which it determines that the point is on
    the circle edge, vs. being on the sphere edge. In the case of circle edge
    express the normal as outwards from the circle.

    Find closest point on biconvex to another point (point is outside the biconvex)

    This breaks down into:

        a) closest point on sphere -- easy
        b) closest point on circle -- project to xz plane, normalize and multiply by circle radius

    Determine dot at edge of biconvex (eg. within which the plane collision 
    will be a collision with the circle, not the sphere surface...)

    This angle can be determined by looking at the origin of one of the generating
    spheres, and determining the angle between the x axis, and the line to the side
    of the biconvex shape.

    Use this to rework the plane collision to determine the dot range
    in which the plane must collide with the circle, and not the sphere
    surfaces.

    Add tests for top, buttom and edge cases of biconvex vs. plane

    Fix the function so that the results are what we expect!

    Rework function so we get information about nearest point even
    if the plane and biconvex are not colliding yet.

    Get unit testing framework integrated into the project

    Convert all printf tests over to unit tests.

    Problem with nearest point on biconvex surface, it is giving NaNs
    for trivial points outside the biconvex, eg. (0,10,0) above the 
    biconvex should result in (0,0.5,0)

    Convert plane biconvex intersection. Make sure all three cases
    are properly tested:

        1. top surface
        2. sphere surface
        3. circle edge
    
    I still want a "pm dev" console app that I can use to just printf
    and explore various things, as well as "pm test" and "pm go" for
    the actual opengl program.

    For the moment the quickest way to get all this stuff going is to
    just have it all in VirtualGo.cpp. Over structuring is a waste of 
    my time.

    So to get this working have VIRTUALGO_TEST, VIRTUALGO_CONSOLE
    defined with separate behavior for these guys, and default
    is to run the real program (eg. "pm go")
