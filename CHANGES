
Work on iOS app (14/4/2013):
----------------------------

    Get basic stone physics into iOS app

    Get basic collision working with floor

    Hook up gravity to be driven by the accelerometer

    *** WOW!!! ***

    Tune elasticity and friction

    Add the jerk acceleration to the stone

    Adjusted to size 40 stone as it has a cool lazy wobble!


Various post-GDC fixes (14/4/2013):
-----------------------------------

    Convert to right handed coordinates (WIP fixing up)

    Fixed biconvex support

    Fixed weirdness with camera zoom levels

    Fixed stone strafe sliding directions

    Contact point is wrong with biconvex vs. primary surface

    Re-enable energy kinetic energy post-collision test. Works with epsilon!

    Fix lighting in collision demo

    Remove VirtualGo.cpp demo -- too similar to collision demo

    Tessellation demo appears to be inside out?

    Why are cracks showing in tessellation demo? Not any more!

    Find a way to unify code between xcode and sublime codebases


Ported stone demo to iPad/iPhone (14/4/2013):
---------------------------------------------

    Simple OpenGL rendering with OpenGL ES 2.0

    Detected single tap vs. double tap

    Detected application wake up / sleep

    Disabled different orientations in app

    Read accelerometer value, lowpass to find gravity
    then take the highpass to detect acceleration jerks

    Determine appropriate zoom level for iPhone vs. iPad so the
    go stone at zoomed out mode is actual size, and in zoomed in
    mode does not clip against the screen bounds.


Separated collision demo, added video recording (17/3/2013):
------------------------------------------------------------

    Separate collision demo

    Add video capture to collision demo

    Add mode where go stone sticks on the board after push out

    Add mode where go stone penetrates the board and freezes

    Render contact point and normal in push out mode in red


Added video recording to support demo (17/3/2013):
--------------------------------------------------

    You can now record video from the support demo

    This gives a good visual demonstration of biconvex support
    witha rotating go stone projecting its bounds onto an axis
    with an orthographic projection.


Added dynamics demo and captured videos for article (16/3/2013):
----------------------------------------------------------------

    Add dynamics demo with:

        1. linear strobe once per-second
        2. linear smooth movement
        3. gravity
        4. angular motion
        5. combination linear and angular motion with gravity

    Add some way to get the strobe remember rigid body snapshots
    and render those. Snapshots should be taken every n seconds,
    where the accumulator is per-mode.

    Snapshots and accumulator should be cleared on mode change

    Tune the snapshots so they record good video / diagrams

    Demo record inputs and playback with video capture

    Capture all videos required for "How The Go Stone Moves"
    and upload to youtube.com

    Urgh. the video quality! =p


Fixed cracks in tesselation (7/3/2012):
---------------------------------------

    Epsilon was set too low when merging vertices, leading to 
    the normals of circle edge not matching with the normals
    of the biconvex, presumably leaving T-joins in the mesh
    between the sphere surface and the bevel torus.

    Increasing the epsilon value from 0.001 to 0.01 cms fixed
    the issue. Easy!

    This value should still be small enough to avoid any overly 
    aggressive vertex welds.


Fixed the damping decay factor so it is framerate independent (7/3/2012):
-------------------------------------------------------------------------

    With a simple adjustment using exponent it is verified to have the
    same amount of damping in super slow-motion as it does when the
    game is running full speed.

    This should also work for adjustments to the number of substep
    iterations in the physics engine as well (this adjusts the dt)


Applied black wood texture to go board (6/3/2012):
--------------------------------------------------

    The black texture looks particularly good with the 
    murasaki go stones!

    I think I'll take this to GDC as my demo.


Applied murasaki texture to go stone (6/3/2013):
------------------------------------------------

    Fixed the lights on the stone to look a lot better

    Create a new mode "Textured" (5)

    Integrate stb_image and load murasaki.jpg

    Create opengl texture objects

    Extend the tesselator so that it generates UV coordinates

    Extend the mesh render so it emits texture UVs

    Improve the lighting on the board

    Render the background as dark grey so black stones
    have some chance of being visible :)

    Work out why the fuck the texture is not showing up

    glGenerateMipmap :)

    Enabled anisotropic filtering

    Enabled trilinear filtering

    Apply murasaki texture to the go stone


Applied hacked damping and rolling/spinning friction (5/3/2013):
----------------------------------------------------------------

    The actual spinning/rolling friction specified in this paper
    is quite complicated and most likely overkill.

    http://physbam.stanford.edu/~fedkiw/papers/stanford2003-01.pdf

    Although it would be very nice to explore in the future,
    for now I've just created a hack with a variable amount 
    of damping propertional to the angualar velocity length.

    The trick was to have two values of damping while in contact
    a low damping value while angular rotation is large, and a
    smaller value for when angular rotation is small.

    To make the transition between these two values less obvious
    I added some interpolation between a transition angvel length
    range.

    This hack gives a reasonable approximation of what I want

     1. good coin spinning type movement
     2. rapid settling once the coin spin motion collapses
     3. good natural looking wobbles when coming to rest for all stones sizes

    So simple and works so good it should be a crime! :)


Fixed wireframe view, provide stone drop type selection (5/3/2013):
-------------------------------------------------------------------

    Fix the wireframe view, it's all broken with z-testing again

    Provide some way to select between initial stone drop conditions,
    
    eg:

        F1 = flat, 
        F2 = 45 degrees
        F3 = vertical
        F4 = 45 degrees more
        F5 = random orientation
        F6 = random orientation with spin


Finished edge and corner cases (5/3/2013):
------------------------------------------

    It is difficult to tell 100% but it seems that the stone is not
    colliding perfectly with the edge, but has some separation out
    from the edge -- sliding the stone off the edge then zooming in
    should help determine if this is actually happening

    No, it is working fine as shone by sliding the stone up onto the 
    side edge from off the board, it lines up perfectly.

    Need another key mapping for zoom level now that I'm using CTRL
    left/right/up/down to apply a linear impulse to the stone.

    Hacked it in, now zoom level is ALT-CTRL+UP/DOWN (shoot me)

    Implement the remaining side cases

    Implement bottom left corner case

    Bottom right corner

    Top left corner

    Top right corner


Work on left edge side for board (5/3/2013):
--------------------------------------------

    Implemented function to get nearest point on line and biconvex

    This will be used for the left edge

    Implemented the top and left side cases for the biconvex nearest
    point to the board, seem to be working OK.

    The plan for left side is as follows:

        1. Test the primary plane, but ignore if point is outside bounds
        2. Test the side plane, but ignore if point is outside bounds
        3. Test the edge, by definition cannot be outside bounds

    So far the first two cases are implemented and seem to be working

    Next I am hooking up the left side edge case

    Once this is done it should be relatively easy to generalize
    to all edges, eg. break up into a function so there is not
    a lot of cut & paste.

    Integrate nearest point on left edge case

    Visualized nearest point between stone and board. Seems to be working

    Why is the collision response suspect when hitting the side edge?

    Could it be that the normal is slightly incorrect?

    Should the normal be on the biconvex surface instead of the edge
    normal, is this what is wrong?!

    Found it: the nearest point on biconvex vs. line function was wrong

    Reworking the function so that it considers the sphere and the
    circle edge cases properly, and takes the closest point to the 
    line.

    There appears to be one final broken case now. Perhaps it is a fuckup
    with the top sphere vs. the bottom sphere? YES! It was!

    Need to be able to slide the stone off the edge

    Implemented this by adding linear impulse on CTRL + LEFT/RIGHT/UP/DOWN


Go board now has correct dimensions (4/3/2013):
-----------------------------------------------

    Find exact measurements of standard go board dimensions

    Parameterized board by the size (eg: 9, 13, 19), with the height
    of grid cells being slightly larger than the width (japanese style)

    Determine how much border there is for a standard japanese board (15mm)

    Separate the grid rendering from the rendering of the board

    Can now select board size on the fly:

        ALT-1: 9x9
        ALT-2: 13x13
        ALT-3: 19x19

    You can crash the demo if you increase the rotation too much with W
    so I added a clamp to maximum rotational inertia for any rigid body


Polish and new demo features (3/3/2013):
----------------------------------------

    Holding down tab scrolls to focus on the current stone

    If you hold down tab while the stone is moving, the camera 
    roughly tracks the stone

    Fixed the lighting

    Added a small impulse if the go stone is inside the go board
    at the beginning of the frame. This gives a cool trampoline effect
    when you adjust teh size of the go board on the fly.

    You now can add angular velocity with QWE and remove it with R


Lots of work on the GDC 2013 talk demo (2/3/2013):
--------------------------------------------------

    Remove the "Picking" demo as it is visually uninteresting

    Can now globally adjust go stone size via alt+left/right

    Added camera zoom levels driven by up/down 

    Make the go board have a center which is the grid point, not the 
    grid center. Asthetically any go player will find it strange otherwise
    (I do)

    Calculating the inertia tensor is too slow. Worked around with less precision

    Escape now restores defaults. For the moment this is just stone size 34

    Enter now drops a stone in the current mode

    Can now select side views in the board demo. 

    When dropping a stone in side view it drops exactly on the edge

    When switching to non-board views the view selection is reset to center

    Camera movement is now relative to the top of the board so it doesn't
    need to be adjusted for different height boards

    Can now adjust board height via ALT-UP/DOWN

    Switched zoom should be control-UP/DOWN because I need UP/DOWN for
    Z selection on the board, eg. ability to select center, sides and corners.

    Adjusted camera and lighting so +Z is forward into the screen when looking
    down the board side-on. Previously it was hacked up with +X into the screen

    The user can now scroll smoothly along the board with left/right/up/down

    Scrolling feels good now and is no longer limited to the small board

    Added more smoothing for the camera tween and now the view adjustments
    feel less jarring and acceptable. Still would be nicer for them to be
    ore analog than discrete, but it is "good enough" for the moment.

    Switch to the large board by default. Small/large board split removed.

    Demo initially does nothing (black screen) until user selects a demo

    Stone is now properly hidden when behind the board

    Can now scroll up/down in Y axis with A/Z. Height is clamped to
    not go below the top surface of the board.


Work on collision response with board (24/2/2013):
--------------------------------------------------

    Split out collision response into separate functions

    Update collision demo to use collision response functions

    Simplify collision detection with the board into a function
    that detects collision, does the projection out of the board
    and returns a static contact point.

    Collide first with the board then with the floor

    Implement collision detection with the floor and do it in
    the same form, eg. detect collision, perform the projection
    and return a static contact point.

    Adjust the board to have thickness and change it from the
    y=0 plane on the top. Floor should be y = 0, board is above

    Verify everything is working, eg. try a really small board

    Implement a function to render the board


Fixed energy being added by friction impulse (19/2/2013):
---------------------------------------------------------

    Was calculating tangent impulse based on velocity at point
    *before* applying normal impulse.

    In some cases this was adding energy to the system.

    Recalculating velocity at a point post-normal impulse and
    using this in the tangent impulse calculation stopped the
    energy from being added.
    

Switched from linear/angular velocity to momentum (18/2/2013):
--------------------------------------------------------------

    Previous code was using linear/angular velocity as the primary
    quantity.

    Switch to using momentum as primary and calculating linear
    and angular velocity from it as secondary quantities.

    Also fixed an error in the rotational kinetic energy calculation.

    Unfortunately, it still seems that coulomb friction impulse
    is adding energy to the system :(


Work on GDC 2013 talk (14/1/2013):
----------------------------------

    Plan out talk slides

    Determine the set of diagrams and demos that remain to be done

    Create first passes of the diagrams on pen and paper

    Work out what demo sections/visualizations are required

    Break up demo visualizations into separate demos that can
    be run and controlled via keyboard.


Finished tesselation demo (5/1/2013):
-------------------------------------

    Find a way to interpret 0-5 in the naive biconvex render
    so the naive tesselation changes with left/right as wall.

    Add a render mode to tesselation to view the stone
    not in wireframe. Ideally, this would be textured
    as well with better lighting but that can wait!


Properly weld bevel to biconvex at various tesselation levels (4/1/2013):
-------------------------------------------------------------------------

    left/right: adjust tesselation depth, 1 to maximum 5

    Find the vertices at the bottom edge of the biconvex top 
    and sort according to angle around the +y axis

    Next use these vertices as the start vertices for the bevel

    Finally, make the bevel # of rings be determined by the angle
    between the start and finish bevel, this way it should tesselate
    uniformly for various sizes of bevel.


Tesselated bevel torus + implement vertex welding (4/1/2013):
-------------------------------------------------------------

    Tesselate the bevel torus with quads.

    Create vertex buffer structure with normals

    vec3f position
    vec3f normal

    Sketch out interface to build mesh

    Implement grid cell -> hash bucket function

    Determine grid cell for vertex (x,y,z)

    Search in the bucket for a vertex with close enough position *and* normal!

    Add code to insert vertex into bucket if doesn't already exist (eg. push back on list)

    Verify that vertices have actually been welded (eg. print out per-weld w. static counter)

    If vertex is being added within epsilon of another grid cell,
    insert the index to that vertex in the other grid cell as well.

    Without vertex welding:

        18432 triangles
        55296 vertices
        55296 indices

    With vertex welding:

        18432 triangles
        9636 vertices
        55296 indices    

    With vertex welding + non-diagonal adjacent cells:

        18432 triangles
        9570 vertices       <--- correct! it is less!
        55296 indices

    With vertex welding + all adjacent cells (including diagonals):

        18432 triangles
        9570 vertices
        55296 indices


Calculated bevel torus for biconvex stone (3/1/2013):
-----------------------------------------------------

    Determine how to mathematically define the ideal
    torus for the smooth edge on the biconvex solid.

    The input should be the height of the bevel,
    this can then be used to determine the tangent
    at the edge of the sphere

    Knowing the tangent at the edge it should be 
    possible to determine the major and minor radii
    of the torus.


Improved stone tesselation added lighting etc. (1/1/2013):
----------------------------------------------------------

    Render the stone with gouraud shading

    Enable anti-aliasing

    Integrate GNU Tesselation Library
    http://gts.sourceforge.net/index.html

    Recover code from original Virtual Go that performed
    the tesselation of the go stone via GTS.

    Code is crap. Discarded.

    Subdivide the spherical cap by starting with a n-gon shape
    projected on to the sphere, and subdividing the triangles
    in the hexagon shape and projecting out to the sphere.

    5-gon seems to give best result (triangles close to equilateral)

    Generate the bottom of the biconvex

    Split up the code into headers to make it easier to manage


Solved strange energy adding effects (9/9/2012):
------------------------------------------------

    Reworked the collision response from scratch and verified 
    that no additional energy is added.


Calculated volume of biconvex solid (3/9/2012):
-----------------------------------------------

    Write a function to calculate the volume of the stone
    given biconvex width and height

    This means I'll need to do an integral for sphere volume
    but only for the top bit and bottom bits of the sphere

    Measure how much the stone weighs in real life

    Determine approximately what the density of the stone
    is, this will allow me to calculate the inertia tensor
    via the numerical integration

    Fixed a bug where linear impulse was not being scaled
    by inverse mass. This is explains the strange behavior
    that was occuring with different mass values.
    

Numerically integrated inertia tensor for biconvex solid (3/9/2012):
--------------------------------------------------------------------

    The inertia tensor is the sum of all moments (r^2*point mass)

    So I just iterated across the xyz bounds and summed up the
    moments numerically. This gives me an approximation for the
    inertia tensor which is pretty sweet.

    It seems that the ratio of the inertia tensor to the mass,
    or the *closeness* of it to 1.0 elements is quite important
    for the stability of the simulation.

    It would seem really that the only thing that matters is
    the ratio between the xz and the y inertia tensor, and (possibly)
    the ratio between the mass and the inertia tensor values

    But linear mass is probably irrelevent in the collision between
    stone and board, since the board is treated as having infinite
    mass.

    It would only kick in when I do stone vs. stone collision?

    No. I think it matters because the mass is an input to the
    collision response even vs. the board. Should study the effect
    that the ratio of the mass vs. the inertia tensor values has


Switched to ellipsoid inertia tensor (2/9/2012):
------------------------------------------------

    Write function for inertia tensor of a sphere given radius/mass

    Write function for inertia tensor of an ellipsoid    

    Retuned simulation based around inertia tensor given
    an ellipsoid with axes (1,0.5,1), which isn't EXACT
    but it's pretty damn close!


Switch to left handed coordinate system (2/9/2012):
---------------------------------------------------

    There is something wrong with my angular velocity math
    or with my velocity at point function, because I have
    had to explicitly invert the quaternion -> matrix
    conversion, and negate the angular impulse

    OpenGL coordinate system is right handed.

    Thought it was left handed. Switched!

    Verified that quat -> matrix needs transpose,
    otherwise rotation is in the opposite direction
    to what I expect.

    Verified that angular velocity is integrating properly
    eg. angular velocity of (0,0,20) rotates counter-clockwise
    around the z axis (positive direction, left handed rule)

    So then where is the inversion?

    It would SEEM that it must be inside my impulse calculation
    or in my velocity at point on rigid body function, because
    the angular velocity integration is working properly!


Implemented normal impulse and coulomb friction impulse (27/8/2012):
--------------------------------------------------------------------

    Calculate impulse as per-wikipedia entry formala
    for restitution:

    http://en.wikipedia.org/wiki/Collision_response

    Applied friction impulse from Erin's GDC tutorial


Aborted POI approach. I misunderstood speculative contacts! (21/8/2012):
------------------------------------------------------------------------

    There is some very strange problem with the collision
    response. It appears to get "stuck" often, indicating
    that the bisection is not 100% correct?

    My guess would be that the bisection is incorrectly
    thinking that the stone is moving towards the board
    and stopping dt advancement

    The collision response is not properly implementing
    the sort of sliding behavior I am looking for if a stone
    slides down on a surface edge it should slide out.

    It seems that my understanding of speculative contacts
    was entirely incorrect. It seems I am implementing
    something different, also I do not understand how
    rolling and sliding contacts work within speculative
    contacts...


Really crappy collision response + friction (19/8/2012):
--------------------------------------------------------

    Added a small amount of damping to linear and angular
    velocity so the system does not explode.

    Also added a totally bullshit friction impulse to the
    collision response so the impulse is not purely in the
    plane normal direction (the stone tumbles around)


First pass collision response (19/8/2012):
------------------------------------------

    Need a function to determine rigid body velocity at point

    Need a function to apply an impulse at a point

    Add a new demo for collision response (7)

    Perform collision response such that an impulse is applied
    that removes the velocity *into* the plane surface at the
    point of collision.


Added function to determine closest features on board and stone (18/8/2012):
----------------------------------------------------------------------------

    Now we need a function that gives us the closest point
    on the biconvex to the plane.

    Basically, we want to ask the question -- what is the 
    closest (or deepest) point on the biconvex re. the plane,
    and then we want to project this point onto the plane surface

    The logic on this should be similar to finding the point
    that is projected onto the axis for the SAT, eg. this 
    would be the point that becomes projected s1

    The normal should always be directly up.

    Extended function so that it returns separate points and normals
    on the stone and on the board, eg:

        stonePoint
        stoneNormal
        boardPoint
        boardNormal

    Visualized board point+normal as red line, and stone point+normal
    as yellow line. Verified that they are working properly.

    Worked around a problem with transforming a plane, the W coordinate
    was not being correctly transformed. Slow workaround function is 
    working properly in the interim.


Bisect to find point of stone/board collision (18/8/2012):
----------------------------------------------------------

    Bisect to find exact point of collision

    The stone moves so fast that it tunnels inside the plane
    when it falls from a height.

    Fix this by subdividing the step searching for the first
    time where the stone collides with the board.

    Freeze the stone at this time and verify visually
    that it is not penetrating with ortho projection.


Stone board collision test now uses SAT (18/8/2012):
----------------------------------------------------

    Convert stone vs. board intersection test to use SAT
    instead of using exact point/normal plane test w. biconvex

    We only care about the binary result we do not want the 
    collision point and normal.


Added bisection demo in ortho projection (9/8/2012):
----------------------------------------------------

    Now I can see the result of the collision and determ whether
    any penetration into the plane surface exists.

    Next step, implement the bisection!


Simple collision detection between stone and board (8/8/2012):
--------------------------------------------------------------

    Implement collision detection between stone and board

    First I just need a boolean function that just says:

        Stone vs. Board intersecting? (true/false)

    When the stone has collided, detect this and freeze it
    in place so it does not move until "space" is pressed.


Angular motion for stone (8/8/2012):
------------------------------------

    Bring back quaternion class

    Implement simple integration of angular velocity -> quat delta (spin)

    Convert position/quaternion combo to rigid body matrix

    Stone should now tumble as it falls

    Randomize initial stone angular velocity


First pass stone kinematics (7/8/2012):
---------------------------------------

    Added a new demo that shows a falling stone with linear motion only

    Stone falls under gravity and passes right through the board


Visualize nearest point on biconvex function (7/8/2012):
--------------------------------------------------------

    When ray is not hitting stone, draw a yellow line between
    the intersection with the plane and the nearest point on
    the biconvex surface.

    This will let me verify that the nearest point on biconvex
    relative to another point is correct -- the point will always
    by definition be *outside* the biconvex, otherwise the pick ray
    would have hit the biconvex stone first.


Implement ray vs. board intersection (7/8/2012):
------------------------------------------------

    Implement ray vs. plane intersection

    Implement ray vs. board intersection 
    (for the moment, just test the primary surface and verify
     that the ray hit is within width/height bounds on plane...)

    Detect whether ray is hitting board or stones via t

    Show normal when hitting board


Visualized biconvex support along x-axis (6/8/2012):
----------------------------------------------------

    The dot threshold was incorrect. Was 1-sphereDot,
    but sphereDot was the correct value.

    When looking at biconvex circle span with ortho projection
    it appears to be correct. The perspective was throwing it
    off!

    Biconvex support now looks visually correct!


Visualized stone + board (6/8/2012):
------------------------------------

    Visualize stone vs. board intersection with blue line
    from point out along normal

    Stone vs. board intersection point appears to be incorrect
    when the sphere surface is nearest to the plane.

    Fixed calculation for sphere surface intersection point.


Render stone + board (5/8/2012):
--------------------------------

    Find some way to switch between modes

        eg. 1 = rotating stone
            2 = stone + board

    Zoom out to show the stone from a distance without rotation

    Render the board in wireframe according to dimensions and some
    tesselation factor

    Now render the board and the stone in the same app


Implemented mouse picking (5/8/2012):
-------------------------------------

    Intersect ray with biconvex and render point and normal
    of intersection if exists.

    Don't hide the mouse

    Space toggles rotation of the stone

    Add function to get mouse xy coordinates 

    Turn mouse xy into pick ray
    http://stackoverflow.com/questions/2093096/implementing-ray-picking

    Verify that intersection under mouse *LOOKS* correct


Render go stone as quads (5/8/2012):
------------------------------------

    Extend go stone render to render in quad strips + triangle
    strips for top section.

    Render quads in wireframe

    Render quads in wireframe with backface culling


Render go stone in wireframe (5/8/2012):
----------------------------------------

    It should be reasonably easy to render a wireframe
    go stone at the origin, pick a # of segments, then
    radially rotate about the origin and draw

    Then extend this to support a rigid body transform
    for the go stone and render it with that

    Next, allow the go stone to rotate about an axis
    and visualize the intersection point and normal with
    the board in wireframe


Implemented stone vs. board primary surface case (4/8/2012):
------------------------------------------------------------

    To handle intersection between biconvex stone and plane:

        1. transform plane into biconvex local space
        2. determine intersection in local space (done)
        3. if intersecting, transform point/normal into world space

    Unit tested simple case at origin with no rotation.

    Unit tested translated away from origin with no rotation.

    Unit tested rotated 180 degrees at origin (upside down)

    Unit tested rotated 180 degrees away from origin.

    Unit tested +/- 90 degrees rotation cases away from origin 
    (circle edge of biconvex solid)

    I can now be confident that the local to world / world to 
    local, transform plane, transform point, transform normal
    fns are all working correctly.


Rigid Body Transform (2/8/2012)
-------------------------------

    Added "RigidBodyTransform" class with cached local -> world,
    and world -> local transforms.

    Added helper function to get world position from transform.

    Implemented rigid body transform inverse, eg. world -> local.


Added board class and stone vs. board collision type test (1/8/2012)
--------------------------------------------------------------------

    Added stone class with dimensions width, height and thickness.

    Categorized stone vs. board collision into cases, eg. primary
    surface, no collision, left edge, top-right corner etc.

    Sketched out stone vs. board collision test function logic

    Unit tested the board collision type function.


Implemented Biconvex vs. Biconvex SAT test (26/7/2012)
------------------------------------------------------

    Write function to determine projection of biconvex onto a line.

    Implement basic unit tests of the span across xyz axes

    Determine set of axes to test one biconvex vs. another. 
    I believe if it is all combinations of lines between sphere
    centers, and a line from the center of each biconvex through
    the circle plane, to the projection of the other biconvex center
    onto the circle plane. YES!

    Write a function that determines the projection of a biconvex
    with a rigid body transform onto a line. This will be used for
    determining the projection of the "other" biconvex.

    Implement a biconvex vs. biconvex SAT function which accepts
    world space position/up per-biconvex and returns true if they
    are intersecting.


Basic OpenGL display (24/7/2012):
---------------------------------

    Link to OpenGL, Carbon etc from premake

    Get a fullscreen opengl display going (bring in from "Cube" demo...)


Added intersection and collision functions for biconvex solid (22/8/2012)
-------------------------------------------------------------------------

    Restore basic biconvex class with math to determine sphere radius
    and offset for a given biconvex width and height.

    Get the vector library back up and running from scoopr. 
    Don't resurrect my own crappy library that isn't SIMD!!!

    Copy across useful code from old biconvex mathematics
    routines, eg. 

        0. ray vs. sphere
        1. ray vs. biconvex (local space)

    Quick test to determine if a point is inside the biconvex.

    Add a function to determine if a point is on the biconvex surface within epsilon.

    Determine normal given a point on the biconvex surface.
    This should accept an epsilon in which it determines that the point is on
    the circle edge, vs. being on the sphere edge. In the case of circle edge
    express the normal as outwards from the circle.

    Find closest point on biconvex to another point (point is outside the biconvex)

    This breaks down into:

        a) closest point on sphere -- easy
        b) closest point on circle -- project to xz plane, normalize and multiply by circle radius

    Determine dot at edge of biconvex (eg. within which the plane collision 
    will be a collision with the circle, not the sphere surface...)

    This angle can be determined by looking at the origin of one of the generating
    spheres, and determining the angle between the x axis, and the line to the side
    of the biconvex shape.

    Use this to rework the plane collision to determine the dot range
    in which the plane must collide with the circle, and not the sphere
    surfaces.

    Add tests for top, buttom and edge cases of biconvex vs. plane

    Fix the function so that the results are what we expect!

    Rework function so we get information about nearest point even
    if the plane and biconvex are not colliding yet.

    Get unit testing framework integrated into the project

    Convert all printf tests over to unit tests.

    Problem with nearest point on biconvex surface, it is giving NaNs
    for trivial points outside the biconvex, eg. (0,10,0) above the 
    biconvex should result in (0,0.5,0)

    Convert plane biconvex intersection. Make sure all three cases
    are properly tested:

        1. top surface
        2. sphere surface
        3. circle edge
    
    I still want a "pm dev" console app that I can use to just printf
    and explore various things, as well as "pm test" and "pm go" for
    the actual opengl program.

    For the moment the quickest way to get all this stuff going is to
    just have it all in VirtualGo.cpp. Over structuring is a waste of 
    my time.

    So to get this working have VIRTUALGO_TEST, VIRTUALGO_CONSOLE
    defined with separate behavior for these guys, and default
    is to run the real program (eg. "pm go")
