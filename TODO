DONE:

    Tesselate the bevel torus with quads.

    Split off a "Tesselation.cpp" demo app

    Create vertex buffer structure with normals

    vec3f position
    vec3f normal

    Sketch out interface to build mesh

    Implement grid cell -> hash bucket function

    Convert bevel tesselation to triangles.

    Add triangles to mesh when generating biconvex

    Add a temporary function to render mesh via glBegin/glEnd

    Verify that biconvex mesh renders properly

    Determine grid cell for vertex (x,y,z)

    Search in the bucket for a vertex with close enough position *and* normal!

    Add code to insert vertex into bucket if doesn't already exist (eg. push back on list)

    Verify that vertices have actually been welded (eg. print out per-weld w. static counter)

    If vertex is being added within epsilon of another grid cell,
    insert the index to that vertex in the other grid cell as well.

    Without vertex welding:

        18432 triangles
        55296 vertices
        55296 indices

    With vertex welding:

        18432 triangles
        9636 vertices
        55296 indices    

    With vertex welding + non-diagonal adjacent cells:

        18432 triangles
        9570 vertices       <--- correct! it is less!
        55296 indices

    With vertex welding + all adjacent cells (including diagonals):

        18432 triangles
        9570 vertices       <--- seems we got lucky. no less verts
        55296 indices

    Implement lots of cool input control inside the tesselation app

    1,2,3 

        switch between naive tesselation, recursive no bevel, recursive with bevel

    tried increasing bucket size. it has no effect on speed. bad hash?

    work out why tesselation of the shape is slow under certain
    conditions, eg. no bevel

    i would guess that we probably have a bad hash function,
    leading to one bucket getting very large.

    first, print the largest bucket size

    yes, the bucket size is large

    the problem has something to do with the treatment of normals

    why would normals be slightly different for what should be
    *exactly* the same normal -- eg. all normals are just a function
    of position, eg. normalize vector between point and center sphere (?!)

    the problem was that the bevel had collapsed to zero so lots of
    vertices with different normals were squished together.

TODO:

    -----------------------------------------------

    Fix the subdivision tesselation so +y is up 

    -----------------------------------------------

    left right:

        adjust tesselation depth, 1 to maximum 5

    up down:

        adjust display of tesselaton in wireframe thick red
        goes from range 0 (no display) to 6 (max+1 no display)

    4

        show a display of various stones in profile, mimicking one of the images
        of go stones of different shapes in side-profile.

    ----------------------------------------------
    
    Implement talk overview with title slides and notes

    ----------------------------------------------

    Create proper OpenGL vertex buffer / index buffer object 
    using code from cube demo. Should be much faster to render stone

    ----------------------------------------------

    Write a vertex shader to generate uvs as a function of xy

    Render a stone with a white texture

    Render the stone with specular highlight

    ----------------------------------------------

    Render the board with a wood texture

    Render the lines and the circles at the star points (9x9)

    ----------------------------------------------

    Advanced Rendering

    Enable anisotropic filtering

    Study the OpenGL shader guide to work out how to do basic shaders

    Add a toggle mode to rotate between different camera views

    Render a blurred out reflection of the stones on the board

    ============================================================






    --------------------------------------------------------------------

    Need to add a concept of rolling friction. Otherwise the stone
    never comes to rest if it is spinning around the Y axis on the board.

    (the point is not moving, therefore no friction force is applied)

    --------------------------------------------------------------------

    Determine why the stone jitters at one step.

    What is going on? Where does the jitter come from?

    Why is it reduced with multiple substeps?

    Can I reduce the jitter without multiple substeps?

    --------------------------------------------------------------------



    ============================================================

    *** IMPLEMENT STONE VS. BOARD EDGE AND CORNER CASES! ***

    Implement biconvex vs. line intersection

    IMPORTANT: not ray intersection, but point/normal
    of intersection of biconvex against an edge!

    Assume that the line is infinite

    Based around nearest point on the line to the sphere,
    then it is just comparing the projected point to see
    if it is on the biconvex surface.

    ============================================================

    Implement left edge case SAT:

        1. may collide with primary plane
        2. may collide with left plane
        3. may collide with edge between primary and left plane

    Primary surface case is already implemented

    Left surface case is already implemented (plane again)

    Take the three cases and determine the area with the least
    collision. If any case is not intersecting, then no collision.

    Unit test edge cases:

        not colliding (vertically above)                            -
        not colliding (rotated such that not touching side plane)   |
        not colliding (rotated such that not touching side edge)    /

        colliding (rotated such that touching primary surface)      |
        colliding (rotated such that touching side surface)         -
        colliding (rotated such that touching edge)                 \

    Generalize fn so that it takes two planes as input, and finds
    the edge from these planes, and uses that to implement SAT.

    Therefore we should be comfortable that this case generalizes
    to the other edges without hard coding all these cases!

    Extend the to all edges.

    Unit test all edge cases.

    ============================================================

    Implement one corner case via SAT (top-left)

    Unit test corner case.

    Extend to all corners.

    ============================================================




 
    ============================================================

    Visualize stone vs. stone SAT

    Two stones rotating next to each other.

    Visualize their x/y axis supports for each stone.

    Add some vis when they are colliding.

    Consider whether or not we need additional separating
    axes than the current, it should be clear from the vis.

    ============================================================

    Implement nearest point on biconvex vs. biconvex

    This is required to determine the collision point and normal
    between two stones after bisecting to find intersection t.

    Visualize nearest points between biconvex if not intersecting
    in yellow.

    Add some key to move the biconvex further away from each other
    or closer together (left/right)

    ============================================================

    Generalize stones to an array of rigid bodies, array of
    biconvex shapes (don't assume all the same size...)

    Determine algorithm for detecting collisions globally

    Study speculative contacts approach and think through

    What about "ghost" contacts?!

    End result, should have a bunch of stones falling while you
    are holding space bar down. These stones should tumble and
    collide and come to rest on the board.
