
DONE:

    Link to OpenGL, Carbon etc.

    Get a basic opengl display going (bring in from "Cube" demo...)

    Write function to determine projection of biconvex onto a line.

    Implement basic unit tests of the span across xyz axes

    Determine set of axes to test one biconvex vs. another. 
    I believe if it is all combinations of lines between sphere
    centers, and a line from the center of each biconvex through
    the circle plane, to the projection of the other biconvex center
    onto the circle plane. YES!

    Write a function that determines the projection of a biconvex
    with a rigid body transform onto a line. This will be used for
    determining the projection of the "other" biconvex.

    Implement a biconvex vs. biconvex SAT function which accepts
    world space position/up per-biconvex and returns true if they
    are intersecting.

TODO:

    Biconvex vs. Biconvex

        Test the biconvex SAT function and fix the biconvex span function
        so that it gives correct results off the primary axes
        (check the dot threshold!)

        Extend so that once we know intersection we can determine
        the point and normal to push out. Should this be done with
        SAT or some hand crafted test based on nearest features?

    Interactive Demo

        Bring back Render.h/Camera.h in a basic form from the Cube demo
        so I don't have to rewrite my own system again, but cut down
        dramatically to just what I need.

        Bring back code to generate the go stone given a biconvex share
        and a desired amount of bevel along the edge (radius of bevel).

        Get back to an interactive demo showing a go board and a single stone

        The go board should be zoomed in, the stone should be a white stone

        Need a wireframe mode and debug visualization so we can test various
        queries, such as nearest point to biconvex, biconvex vs. plane,
        biconvex vs. other biconvex interactively.

    Physics:

        Once satisfied that the basic queries are good quality implement physics

        The idea would be that an impulse based simulation is probably the best
        way to go, ideally reusing the idea of speculative contacts so resting
        contact is completely stable with no jitter.

        First implement the stone drop with gravity with only linear motion

        Verify that the stone properly drops and bounces against the plane
        without linear motion and does not penetrate.

        Next, determine how to implement angular collision response

        Next, determine how to implement friction

        At this point the stone should bounce and move realistically.
