DONE:

    ...

TODO:

    Collision between Go Stones and Board

        Need a function to take a position/quaternion and generate 
        local -> world and world to local matrices.

        Also need a function to take a given rotation matrix and position
        and generate local -> world, world -> local matrices (for tests)

        Implement stone vs. board primary surface case:

            1. transform plane into biconvex local space   --->   can this be done efficiently with vec4f?
            2. determine intersection in local space (done)
            3. if intersecting, transform point/normal into world space
            4. determine penetration depth by testing point vs. plane

        Unit test the primary surface case.

        Implement one edge case via SAT (left)

        Unit test edge case.

        Extend the to all edges.

        Unit test all edge cases.

        Implement one corner case via SAT (top-left)

        Unit test corner case.

        Extend to all corners.

    Biconvex vs. Biconvex

        Extend so that once we know intersection we can determine
        the point and normal to push out. Should this be done with
        SAT or some hand crafted test based on nearest features?

        I think with the SAT test the way it is sorted, I already know
        the nearest feature being considered, eg. it is a point on the
        sphere edge, or a point on the circle edge.

        In fact, by determining the point first, and skipping cases 
        where the nearest point feature is on the shadow side of the
        sphere, it will probably make the SAT test faster.

        I think that I should have two versions of the test

            1. A fast version that just determines intersecting yes/no

            2. A slow version that determines normal, point of intersection

        This would allow me to keep the simple test as is, and add a
        more complicated one that would track nearest feature etc.

        I should try to find a way to convert the simple binary SAT
        so that it doesn't require unit axis vectors. The sqrt here
        is going to significantly slow down the test.

    Interactive Demo

        Bring back Render.h/Camera.h in a basic form from the Cube demo
        so I don't have to rewrite my own system again, but cut down
        dramatically to just what I need.

        Bring back code to generate the go stone given a biconvex share
        and a desired amount of bevel along the edge (radius of bevel).

        Get back to an interactive demo showing a go board and a single stone

        The go board should be zoomed in, the stone should be a white stone

        Need a wireframe mode and debug visualization so we can test various
        queries, such as nearest point to biconvex, biconvex vs. plane,
        biconvex vs. other biconvex interactively.

    Physics:

        Once satisfied that the basic queries are good quality implement physics

        The idea would be that an impulse based simulation is probably the best
        way to go, ideally reusing the idea of speculative contacts so resting
        contact is completely stable with no jitter.

        First implement the stone drop with gravity with only linear motion

        Verify that the stone properly drops and bounces against the plane
        without linear motion and does not penetrate.

        Next, determine how to implement angular collision response

        Next, determine how to implement friction

        At this point the stone should bounce and move realistically.
