
DONE:

    Link to OpenGL, Carbon etc.

    Get a basic opengl display going (bring in from "Cube" demo...)

    Write function to determine projection of biconvex onto a line.


TODO:

    Biconvex vs. Biconvex

        Simplify circle case. I don't think that it is necessary
        to do the normalize and project just to get it working.

        Write a function that determines the projection of a biconvex
        with a rigid body transform onto a line. This will be used for
        determining the projection of the "other" biconvex.

        Determine set of axes to test one biconvex vs. another. 
        I believe if it is all combinations of lines between sphere
        centers, and a line from the center of each biconvex through
        the circle plane, to the projection of the other biconvex center.
        Not sure about this last one though.

        Once biconvex works with SAT then we can use the area of most
        least overlap as the area to push out. This is the "least" work
        way to push out of the object. But is this correct?

    Interactive Demo

        Bring back Render.h/Camera.h in a basic form from the Cube demo
        so I don't have to rewrite my own system again, but cut down
        dramatically to just what I need.

        Bring back code to generate the go stone given a biconvex share
        and a desired amount of bevel along the edge (radius of bevel).

        Get back to an interactive demo showing a go board and a single stone

        The go board should be zoomed in, the stone should be a white stone

        Need a wireframe mode and debug visualization so we can test various
        queries, such as nearest point to biconvex, biconvex vs. plane,
        biconvex vs. other biconvex interactively.

    Physics:

        Once satisfied that the basic queries are good quality implement physics

        The idea would be that an impulse based simulation is probably the best
        way to go, ideally reusing the idea of speculative contacts so resting
        contact is completely stable with no jitter.

        First implement the stone drop with gravity with only linear motion

        Verify that the stone properly drops and bounces against the plane
        without linear motion and does not penetrate.

        Next, determine how to implement angular collision response

        Next, determine how to implement friction

        At this point the stone should bounce and move realistically.
