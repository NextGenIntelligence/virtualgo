DONE:

    ...

TODO:

    ============================================================

    Convert stone vs. board intersection test to use SAT
    instead of using exact point/normal plane test w. biconvex

    We only care about the binary result we do not want the 
    collision point and normal.

    ============================================================

    Bisect to find exact point of collision

    The stone moves so fast that it tunnels inside the plane
    when it falls from a height.

    Fix this by subdividing the step searching for the first
    time where the stone collides with the board.

    Freeze the stone at this time and verify visually
    that it is not penetrating (eg: perhaps put the camera
    down on the line, and give it an ortho transform? +
    draw collision plane in thick blue line

    ============================================================

    Next we need to determine the point of collision

    Now we need a function that gives us the closest point
    on the biconvex to the plane.

    We also need to decide what the normal should be

    Should the normal always be directly up? OR in the case of
    the circle edge touching the plane should the normal be back
    towards the biconvex center from the nearest point?

    ============================================================

    Implement collision response

    Determine velocity at a point for rigid body (add fn to
    rigid body class). 

    Perform collision response such that an impulse is applied
    that removes the velocity *into* the plane surface at the
    point of collision.

    ============================================================

    Implement damping

    There should be some small damping added to the simulation
    to linear and rotational velocity.

    Research the best way to implement this that is 
    most appropriate resistance against motion in air.

    ============================================================

    Implement friction

    Study Coulomb friction and how it works

    Study how impulse based systems approximate friction

    I want proper resting friction, eg. static and dynamic
    friction because the effects are required for stones to
    rest on each other without looking slimy or fake.

    ============================================================

    Visualize stone vs. stone SAT

    Two stones rotating next to each other.

    Visualize their x/y axis supports for each stone.

    Add some vis when they are colliding.

    Consider whether or not we need additional separating
    axes than the current, it should be clear from the vis.

    ============================================================

    Implement nearest point on biconvex vs. biconvex

    This is required to determine the collision point and normal
    between two stones after bisecting to find intersection t.

    Visualize nearest points between biconvex if not intersecting
    in yellow.

    Add some key to move the biconvex further away from each other
    or closer together (left/right)

    ============================================================

    Generalize stones to an array of rigid bodies, array of
    biconvex shapes (don't assume all the same size...)

    Determine algorithm for detecting collisions globally

    Study speculative contacts approach and think through

    What about "ghost" contacts?!

    End result, should have a bunch of stones falling while you
    are holding space bar down. These stones should tumble and
    collide and come to rest on the board.

    ============================================================









    ============================================================

    MUCH LATER BELOW...
    
    ============================================================

    Implement biconvex vs. line intersection

    IMPORTANT: not ray intersection, but point/normal
    of intersection of biconvex against an edge!

    Assume that the line is infinite

    Based around nearest point on the line to the sphere,
    then it is just comparing the projected point to see
    if it is on the biconvex surface.

    ============================================================

    Implement left edge case SAT:

        1. may collide with primary plane
        2. may collide with left plane
        3. may collide with edge between primary and left plane

    Primary surface case is already implemented

    Left surface case is already implemented (plane again)

    Take the three cases and determine the area with the least
    collision. If any case is not intersecting, then no collision.

    Unit test edge cases:

        not colliding (vertically above)                            -
        not colliding (rotated such that not touching side plane)   |
        not colliding (rotated such that not touching side edge)    /

        colliding (rotated such that touching primary surface)      |
        colliding (rotated such that touching side surface)         -
        colliding (rotated such that touching edge)                 \

    Generalize fn so that it takes two planes as input, and finds
    the edge from these planes, and uses that to implement SAT.

    Therefore we should be comfortable that this case generalizes
    to the other edges without hard coding all these cases!

    Extend the to all edges.

    Unit test all edge cases.

    ============================================================

    Implement one corner case via SAT (top-left)

    Unit test corner case.

    Extend to all corners.

    ============================================================
