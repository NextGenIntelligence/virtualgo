DONE:

    Remove the "Picking" demo as it is visually uninteresting

    Can now globally adjust go stone size via alt+left/right

    Added camera zoom levels driven by up/down 

    Make the go board have a center which is the grid point, not the 
    grid center. Asthetically any go player will find it strange otherwise
    (I do)

    Calculating the inertia tensor is too slow. Worked around with less precision

    Escape now restores defaults. For the moment this is just stone size 34

    Enter now drops a stone in the current mode

    Can now select side views in the board demo. 

    When dropping a stone in side view it drops exactly on the edge

    When switching to non-board views the view selection is reset to center

TODO:

    -----------------------------------------------------------------------

    Camera movement should be relative to the top of the board so it doesn't
    need to be adjusted for different height boards

    -----------------------------------------------------------------------

    Should be able to adjust board height via ALT-UP/DOWN

    -----------------------------------------------------------------------

    Calculate the density of slate and shell go stones

    Use this to calculate the exact mass of the stones

    I think that the transition from different stone sizes and the
    rotation rates (due to inertia tensor) are a bit overdone.

    If the inertia is adjusted for mass then it would change less
    when we switch go stone sizes. Is this worth doing?

    -----------------------------------------------------------------------

    It would be nice if random stone would not randomize after the first
    time it was called, eg. I could hold down the button and have the 
    randomized stone hold in the air until I release the button.

    -----------------------------------------------------------------------

    Adjust camera and lighting so that X is left/right and Z is up/down
    on the screen (looking top down...)

    Otherwise its going to get really confusing continually converting
    in my head to looking down the +X axis, especially when the go board
    is adjusted to be taller than it is wide.

    -----------------------------------------------------------------------

    Perhaps zoom should be control-UP/DOWN because I'll need to be able
    to select sides and corners of the go board for dropping the stone
    on corner edge cases and this needs UP/DOWN/LEFT/RIGHT

    -----------------------------------------------------------------------

    Would be nice to be able to adjust stone sizes in the tessellation
    and the support demos.

    Perhaps the easiest way to do this would be to merge these demos
    back into the main VirtualGo.cpp?

    -----------------------------------------------------------------------

    Interpolate the camera transitions. This will require generating UP
    vector as cross product of right and forward vector.

    -----------------------------------------------------------------------

    Would be cool to use left/right to select parts of the board, eg. the
    edges or the corner, or to maybe rotate the board around so you can
    look at each corner and side in turn

    -----------------------------------------------------------------------

    Really want a way to take an input and filter it so that it repeats
    after a certain time held down, but I can still do individual presses
    to select discrete values

    This would be useful for camera changes and go stone size changes

    -----------------------------------------------------------------------

    The board should not be infinite in the linear/angular/friction demo
    It should be the primary surface case only for the board -- so the
    stone will fall off the board if it goes outside the bounds.

    -----------------------------------------------------------------------

    Rotating stone should have more rotation about Y axis initially
    as this results in a pretty cool motion of the stone.

    -----------------------------------------------------------------------

    Need to implement rolling and sliding friction because otherwise the 
    infinite spinning motion of the stone is a little disturbing

    -----------------------------------------------------------------------

    Implement side plane cases for collision with board

    I think the algorithm is very simple.

    Depending on case test SAT against all possible planes, 
    eg. primary case, top plane, side case top and side plane,
    corner case, primary and two side planes.

    Only colliding if overlapping on all planes.

    If colliding either:

    a) Push out in primary plane first, then side etc.

    b) Find the plane with the "least" energy to push out
       and push out along this.

    Does b) have merit? Which cases would be better?

    Once we push the stone out we need to find contact points

    The contact point function needs to be extended to consider
    all planes for the region. When considering non-primary cases
    nearest point on plane needs to be clamped within the bounds
    of the plane surface. This is very very easy.

    Is it possible to have a non-clamped nearest point on one plane
    but be clamped on the other. Is this useful for picking the best
    push out axis?

    Need to add a method for rendering the floor.

    Make the first three collision tests render with the floor,
    or with a larger board. Small board is just for testing edge
    cases (literally...)

    The common case is a stone falling from on top of the board onto
    a side. I think this means generally that preferring to push out
    of the top plane is the best in most cases. You would not want
    a stone falling onto the edge to tunnel and then be pushed out
    to the side.

    However, if you could work out which region the stone was in
    before collision, you could make an informed choice, eg. prefer
    to push out along the same side it was on before collision.

    However, side collisions on the board are so rare, this may not
    be worth the hassle. OHSHIT consider a stone coming to rest on the 
    side of the board. We *MUST* ensure that it isnt pushed above the
    board in this case.

    This means that yes, it is almost certain that we need to choose
    the push axis very intelligently.

    I think we definitely need to consider the previous position when
    choosing the appropriate axis to push out on.

    In the cases where it is not obvious, eg. edge corner regions,
    then it is totally OK to bias towards the top primary surface push
    I think.

    But when the stone is obviously approaching from the side and is
    already below the stone primary surface, you MUST push out along
    the side plane not up above the primary plane!

    Could this be represented by energy? eg. if colliding push out
    along the plane with the smallest penetration?

    ----------------------------------------------

    Add rolling friction

    Add spinning friction

    Add air resistance (drag)

    ----------------------------------------------

    Implement linear kinematics demo

    Implement angular kinematics demo

    Side-by-side demo of linear bouncing with difference elasticities from 0 to 1

    Side-by-side demo of angular collision response with elasticities 0 -> 1

    Same for friction?!

    ----------------------------------------------



    ----------------------------------------------

    Create proper OpenGL vertex buffer / index buffer object 
    using code from cube demo. Should be much faster to render stone

    Write a vertex shader to generate uvs as a function of xy

    Render a stone with a white texture

    Render the stone with specular highlight

    ----------------------------------------------

    Render the board with a wood texture

    Render the lines and the circles at the star points (9x9)

    ----------------------------------------------

    Enable anisotropic filtering

    Add a toggle mode to rotate between different camera views

    Render a blurred out reflection of the stones on the board

    ============================================================

    Visualize stone vs. stone SAT

    Two stones rotating next to each other.

    Visualize their x/y axis supports for each stone.

    Add some vis when they are colliding.

    Consider whether or not we need additional separating
    axes than the current, it should be clear from the vis.

    ============================================================

    Implement nearest point on biconvex vs. biconvex

    This is required to determine the collision point and normal
    between two stones after bisecting to find intersection t.

    Visualize nearest points between biconvex if not intersecting
    in yellow.

    Add some key to move the biconvex further away from each other
    or closer together (left/right)

    ============================================================

    Generalize stones to an array of rigid bodies, array of
    biconvex shapes (don't assume all the same size...)

    Determine algorithm for detecting collisions globally

    Study speculative contacts approach and think through

    What about "ghost" contacts?!

    End result, should have a bunch of stones falling while you
    are holding space bar down. These stones should tumble and
    collide and come to rest on the board.
