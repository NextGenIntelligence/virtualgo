DONE:

    Remove the "Picking" demo as it is visually uninteresting

    Can now globally adjust go stone size via alt+left/right

    Added camera zoom levels driven by up/down 

    Make the go board have a center which is the grid point, not the 
    grid center. Asthetically any go player will find it strange otherwise
    (I do)

    Calculating the inertia tensor is too slow. Worked around with less precision

    Escape now restores defaults. For the moment this is just stone size 34

    Enter now drops a stone in the current mode

    Can now select side views in the board demo. 

    When dropping a stone in side view it drops exactly on the edge

    When switching to non-board views the view selection is reset to center

    Camera movement is now relative to the top of the board so it doesn't
    need to be adjusted for different height boards

    Can now adjust board height via ALT-UP/DOWN

    Switched zoom should be control-UP/DOWN because I need UP/DOWN for
    Z selection on the board, eg. ability to select center, sides and corners.

    Adjusted camera and lighting so +Z is forward into the screen when looking
    down the board side-on. Previously it was hacked up with +X into the screen

    The user can now scroll smoothly along the board with left/right/up/down

    Scrolling feels good now and is no longer limited to the small board

TODO:

    -----------------------------------------------------------------------

    The adjustment of the camera zoom is too abrupt and not appropriate
    to the aesthetics of go. It should be smooth, with probably means I
    have to define a continuous function that can be moved along t in [0,1]

    -----------------------------------------------------------------------

    I want to be able to adjust the camera up/down (y) in a scroll like fashion
    This will allow me to zoom the camera from top-down for example -- and I 
    could even drive this such that the height that the go stone is dropped
    from is a function of my camera height.

    -----------------------------------------------------------------------

    If the camera position is inside or touching the board, it should be
    pushed up some minimum position above the board, eg. 0.1 above the 
    board surface.

    This is necessary now that the user can freely scroll the board

    -----------------------------------------------------------------------

    Why is there a brief flicker of brighter lighting for the first few
    frames? Is the camera not being set properly?

    -----------------------------------------------------------------------

    Demo should initially show nothing because I don't want to have anything
    happen when I relaunch the demo mid-presentation, eg. don't want to see
    a linear stone drop or whatever is first demo each time launching.

    -----------------------------------------------------------------------

    It would be nice if random stone would not randomize after the first
    time it was called, eg. I could hold down the button and have the 
    randomized stone hold in the air until I release the button.

    -----------------------------------------------------------------------

    Would be nice to be able to adjust stone sizes in the tessellation
    and the support demos.

    Perhaps the easiest way to do this would be to merge these demos
    back into the main VirtualGo.cpp?

    -----------------------------------------------------------------------

    Rotating stone should have more rotation about Y axis initially
    as this results in a pretty cool motion of the stone.

    -----------------------------------------------------------------------

    Need to implement rolling and sliding friction

    -----------------------------------------------------------------------

    Implement side plane cases for collision with board

    I think the algorithm is very simple.

    Depending on case test SAT against all possible planes, 
    eg. primary case, top plane, side case top and side plane,
    corner case, primary and two side planes.

    Only colliding if overlapping on all planes.

    If colliding either:

    a) Push out in primary plane first, then side etc.

    b) Find the plane with the "least" energy to push out
       and push out along this.

    Does b) have merit? Which cases would be better?

    Once we push the stone out we need to find contact points

    The contact point function needs to be extended to consider
    all planes for the region. When considering non-primary cases
    nearest point on plane needs to be clamped within the bounds
    of the plane surface. This is very very easy.

    Is it possible to have a non-clamped nearest point on one plane
    but be clamped on the other. Is this useful for picking the best
    push out axis?

    Need to add a method for rendering the floor.

    Make the first three collision tests render with the floor,
    or with a larger board. Small board is just for testing edge
    cases (literally...)

    The common case is a stone falling from on top of the board onto
    a side. I think this means generally that preferring to push out
    of the top plane is the best in most cases. You would not want
    a stone falling onto the edge to tunnel and then be pushed out
    to the side.

    However, if you could work out which region the stone was in
    before collision, you could make an informed choice, eg. prefer
    to push out along the same side it was on before collision.

    However, side collisions on the board are so rare, this may not
    be worth the hassle. OHSHIT consider a stone coming to rest on the 
    side of the board. We *MUST* ensure that it isnt pushed above the
    board in this case.

    This means that yes, it is almost certain that we need to choose
    the push axis very intelligently.

    I think we definitely need to consider the previous position when
    choosing the appropriate axis to push out on.

    In the cases where it is not obvious, eg. edge corner regions,
    then it is totally OK to bias towards the top primary surface push
    I think.

    But when the stone is obviously approaching from the side and is
    already below the stone primary surface, you MUST push out along
    the side plane not up above the primary plane!

    Could this be represented by energy? eg. if colliding push out
    along the plane with the smallest penetration?

    ----------------------------------------------

    Add rolling friction

    Add spinning friction

    Add air resistance (drag)

    ----------------------------------------------



    ----------------------------------------------

    Create proper OpenGL vertex buffer / index buffer object 
    using code from cube demo. Should be much faster to render stone

    Write a vertex shader to generate uvs as a function of xy

    Render a stone with a white texture

    Render the stone with specular highlight

    ----------------------------------------------

    Render the board with a wood texture

    Render the lines and the circles at the star points (9x9)

    ----------------------------------------------

    Enable anisotropic filtering

    Add a toggle mode to rotate between different camera views

    Render a blurred out reflection of the stones on the board

    ============================================================

    Visualize stone vs. stone SAT

    Two stones rotating next to each other.

    Visualize their x/y axis supports for each stone.

    Add some vis when they are colliding.

    Consider whether or not we need additional separating
    axes than the current, it should be clear from the vis.

    ============================================================

    Implement nearest point on biconvex vs. biconvex

    This is required to determine the collision point and normal
    between two stones after bisecting to find intersection t.

    Visualize nearest points between biconvex if not intersecting
    in yellow.

    Add some key to move the biconvex further away from each other
    or closer together (left/right)

    ============================================================

    Generalize stones to an array of rigid bodies, array of
    biconvex shapes (don't assume all the same size...)

    Determine algorithm for detecting collisions globally

    Study speculative contacts approach and think through

    What about "ghost" contacts?!

    End result, should have a bunch of stones falling while you
    are holding space bar down. These stones should tumble and
    collide and come to rest on the board.
