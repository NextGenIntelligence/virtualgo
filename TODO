DONE:

    Remove the "Picking" demo as it is visually uninteresting

    Can now globally adjust go stone size via alt+left/right

TODO:

    -----------------------------------------------------------------------

    Calculating the inertia tensor is too slow.

    Switch entirely to closed form solution ASAP!!!

    -----------------------------------------------------------------------

    Having to press the specific number to drop a stone is annoying now
    because your fingers forget what demo you are in

    Need a way to drop a stone in the current demo via a constant key

    Normally this would be space but that is being used for slowmotion

    -----------------------------------------------------------------------

    Combine all demos into one application VirtualGo

    This makes it easier to demo, switch around and show a progression
    to people when doing a demo.

    The default should be a black screen -- you have to press a button
    to make anything happen: 1,2,3 etc...

        1. Tesselation demo
        2. Support
        3. Linear collision
        4. Angular collision (no friction)
        5. Collision with coulomb friction
        6. Collision with spinning and rolling friction
        7. Collision with board (edge cases etc...)
        8. Textured stone and board with nice lighting
        etc...

    -----------------------------------------------------------------------

    There will be lots of settings so escape needs to return to a default

    -----------------------------------------------------------------------

    The board should not be infinite in the linear/angular/friction demo
    It should be the primary surface case only for the board -- so the
    stone will fall off the board if it goes outside the bounds.

    -----------------------------------------------------------------------

    Need different camera zooms/angles depending on context -- implement
    forward/back up/down and rotate angle on left/right with smoothing
    will provide a very snappy looking way to rotate around the board

    -----------------------------------------------------------------------

    Rotating stone should have more rotation about Y axis initially
    as this results in a pretty cool motion of the stone.

    -----------------------------------------------------------------------

    Need to implement rolling and sliding friction because otherwise the 
    infinite spinning motion of the stone is a little disturbing

    -----------------------------------------------------------------------

    Implement side plane cases for collision with board

    I think the algorithm is very simple.

    Depending on case test SAT against all possible planes, 
    eg. primary case, top plane, side case top and side plane,
    corner case, primary and two side planes.

    Only colliding if overlapping on all planes.

    If colliding either:

    a) Push out in primary plane first, then side etc.

    b) Find the plane with the "least" energy to push out
       and push out along this.

    Does b) have merit? Which cases would be better?

    Once we push the stone out we need to find contact points

    The contact point function needs to be extended to consider
    all planes for the region. When considering non-primary cases
    nearest point on plane needs to be clamped within the bounds
    of the plane surface. This is very very easy.

    Is it possible to have a non-clamped nearest point on one plane
    but be clamped on the other. Is this useful for picking the best
    push out axis?

    Need to add a method for rendering the floor.

    Make the first three collision tests render with the floor,
    or with a larger board. Small board is just for testing edge
    cases (literally...)

    The common case is a stone falling from on top of the board onto
    a side. I think this means generally that preferring to push out
    of the top plane is the best in most cases. You would not want
    a stone falling onto the edge to tunnel and then be pushed out
    to the side.

    However, if you could work out which region the stone was in
    before collision, you could make an informed choice, eg. prefer
    to push out along the same side it was on before collision.

    However, side collisions on the board are so rare, this may not
    be worth the hassle. OHSHIT consider a stone coming to rest on the 
    side of the board. We *MUST* ensure that it isnt pushed above the
    board in this case.

    This means that yes, it is almost certain that we need to choose
    the push axis very intelligently.

    I think we definitely need to consider the previous position when
    choosing the appropriate axis to push out on.

    In the cases where it is not obvious, eg. edge corner regions,
    then it is totally OK to bias towards the top primary surface push
    I think.

    But when the stone is obviously approaching from the side and is
    already below the stone primary surface, you MUST push out along
    the side plane not up above the primary plane!

    Could this be represented by energy? eg. if colliding push out
    along the plane with the smallest penetration?

    ----------------------------------------------

    Add rolling friction

    Add spinning friction

    Add air resistance (drag)

    ----------------------------------------------

    Implement linear kinematics demo

    Implement angular kinematics demo

    Side-by-side demo of linear bouncing with difference elasticities from 0 to 1

    Side-by-side demo of angular collision response with elasticities 0 -> 1

    Same for friction?!

    ----------------------------------------------



    ----------------------------------------------

    Create proper OpenGL vertex buffer / index buffer object 
    using code from cube demo. Should be much faster to render stone

    Write a vertex shader to generate uvs as a function of xy

    Render a stone with a white texture

    Render the stone with specular highlight

    ----------------------------------------------

    Render the board with a wood texture

    Render the lines and the circles at the star points (9x9)

    ----------------------------------------------

    Enable anisotropic filtering

    Add a toggle mode to rotate between different camera views

    Render a blurred out reflection of the stones on the board

    ============================================================

    Visualize stone vs. stone SAT

    Two stones rotating next to each other.

    Visualize their x/y axis supports for each stone.

    Add some vis when they are colliding.

    Consider whether or not we need additional separating
    axes than the current, it should be clear from the vis.

    ============================================================

    Implement nearest point on biconvex vs. biconvex

    This is required to determine the collision point and normal
    between two stones after bisecting to find intersection t.

    Visualize nearest points between biconvex if not intersecting
    in yellow.

    Add some key to move the biconvex further away from each other
    or closer together (left/right)

    ============================================================

    Generalize stones to an array of rigid bodies, array of
    biconvex shapes (don't assume all the same size...)

    Determine algorithm for detecting collisions globally

    Study speculative contacts approach and think through

    What about "ghost" contacts?!

    End result, should have a bunch of stones falling while you
    are holding space bar down. These stones should tumble and
    collide and come to rest on the board.
