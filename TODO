DONE:

    Holding down tab scrolls to focus on the current stone

    If you hold down tab while the stone is moving, the camera 
    roughly tracks the stone

TODO:

    -----------------------------------------------------------------------

    Re-incorporate the tesselation and support demos into the VirtualGo.cpp

    This would allow me to use global controls like adjusting the size of
    the go stone during tesselation and support demos (If I wish...)

    -----------------------------------------------------------------------

    If I hold shift I'd like the camera lookat point to be fixed
    while I scroll up/down, within limits. Is this possible?

    -----------------------------------------------------------------------

    If a go stone is inside the board at the beginning of the frame
    it should be pushed out via a spring impulse proportional to the
    amount of penetration (hookes' law)

    This would make it so that when I expand the size of the go board
    the stone would be launched upwards in a cool trampoline effect

    This would be cool and the fact that it doesn't do this right now
    stands out quite a bit when demoing the dynamic board thickness
    adjustment!

    -----------------------------------------------------------------------

    When the camera is zoomed right into the board and is side on
    detect this and draw a horizontal line representing the board
    surface.

    Obviously this only works in wireframe!

    -----------------------------------------------------------------------

    Why is there a brief flicker of brighter lighting for the first few
    frames? Is the camera or lighting not being set properly?

    -----------------------------------------------------------------------

    Adjusting the go stone size changes the lighting on the board

    Something is wrong!

    -----------------------------------------------------------------------

    Board should be adjusted such that it matches the actual dimensions
    both in x and z, eg. that it is lightly longer than it is wide
    due to perspective.

    -----------------------------------------------------------------------

    Board should be adjustable from a 9x9 to 13x13 and 19x19 on the fly

    The adjustment of board size should feel nice but since it is not
    continuous the rate of expansion should be a function of frames
    the key has been held down.

    Alternatively it could be chosen via ALT-1, ALT-2, ALT-3?

    -----------------------------------------------------------------------

    Board creation and dimensions should be parameterized, eg. from inputs
    such as width/height of cells. Number of grid points, eg. 9x9 etc, amount
    of buffer on the sides for non-grid surfaces and so on.

    -----------------------------------------------------------------------

    It would be nice if random stone would not randomize after the first
    time it was called, eg. I could hold down the button and have the 
    randomized stone hold in the air until I release the button.

    -----------------------------------------------------------------------

    Would be cool to be able to have a button to press that removes the 
    linear and angular momentum of a stone, or at least, clamps it to
    some small amount, this will help in cases where I want to make a
    stone come to rest on the board

    -----------------------------------------------------------------------

    Would be nice to have a button to launch a stone in a spinning
    configuration just a small height above the board

    -----------------------------------------------------------------------

    Need to implement rolling and sliding friction

    -----------------------------------------------------------------------

    Implement side plane cases for collision with board

    I think the algorithm is very simple.

    Depending on case test SAT against all possible planes, 
    eg. primary case, top plane, side case top and side plane,
    corner case, primary and two side planes.

    Only colliding if overlapping on all planes.

    If colliding either:

    a) Push out in primary plane first, then side etc.

    b) Find the plane with the "least" energy to push out
       and push out along this.

    Does b) have merit? Which cases would be better?

    Once we push the stone out we need to find contact points

    The contact point function needs to be extended to consider
    all planes for the region. When considering non-primary cases
    nearest point on plane needs to be clamped within the bounds
    of the plane surface. This is very very easy.

    Is it possible to have a non-clamped nearest point on one plane
    but be clamped on the other. Is this useful for picking the best
    push out axis?

    Need to add a method for rendering the floor.

    Make the first three collision tests render with the floor,
    or with a larger board. Small board is just for testing edge
    cases (literally...)

    The common case is a stone falling from on top of the board onto
    a side. I think this means generally that preferring to push out
    of the top plane is the best in most cases. You would not want
    a stone falling onto the edge to tunnel and then be pushed out
    to the side.

    However, if you could work out which region the stone was in
    before collision, you could make an informed choice, eg. prefer
    to push out along the same side it was on before collision.

    However, side collisions on the board are so rare, this may not
    be worth the hassle. OHSHIT consider a stone coming to rest on the 
    side of the board. We *MUST* ensure that it isnt pushed above the
    board in this case.

    This means that yes, it is almost certain that we need to choose
    the push axis very intelligently.

    I think we definitely need to consider the previous position when
    choosing the appropriate axis to push out on.

    In the cases where it is not obvious, eg. edge corner regions,
    then it is totally OK to bias towards the top primary surface push
    I think.

    But when the stone is obviously approaching from the side and is
    already below the stone primary surface, you MUST push out along
    the side plane not up above the primary plane!

    Could this be represented by energy? eg. if colliding push out
    along the plane with the smallest penetration?

    ----------------------------------------------

    Add rolling friction

    Add spinning friction

    Add air resistance (drag)

    ----------------------------------------------



    ----------------------------------------------

    Create proper OpenGL vertex buffer / index buffer object 
    using code from cube demo. Should be much faster to render stone

    Write a vertex shader to generate uvs as a function of xy

    Render a stone with a white texture

    Render the stone with specular highlight

    ----------------------------------------------

    Render the board with a wood texture

    Render the lines and the circles at the star points (9x9)

    ----------------------------------------------

    Enable anisotropic filtering

    Add a toggle mode to rotate between different camera views

    Render a blurred out reflection of the stones on the board

    ============================================================

    Visualize stone vs. stone SAT

    Two stones rotating next to each other.

    Visualize their x/y axis supports for each stone.

    Add some vis when they are colliding.

    Consider whether or not we need additional separating
    axes than the current, it should be clear from the vis.

    ============================================================

    Implement nearest point on biconvex vs. biconvex

    This is required to determine the collision point and normal
    between two stones after bisecting to find intersection t.

    Visualize nearest points between biconvex if not intersecting
    in yellow.

    Add some key to move the biconvex further away from each other
    or closer together (left/right)

    ============================================================

    Generalize stones to an array of rigid bodies, array of
    biconvex shapes (don't assume all the same size...)

    Determine algorithm for detecting collisions globally

    Study speculative contacts approach and think through

    What about "ghost" contacts?!

    End result, should have a bunch of stones falling while you
    are holding space bar down. These stones should tumble and
    collide and come to rest on the board.
