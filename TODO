DONE:

    ...

TODO:

    ============================================================

    Implement ray vs. plane intersection

    Implement ray vs. board intersection 
    (for the moment, just test the primary surface and verify
     that the ray hit is within width/height bounds on plane...)

    Detect whether ray is hitting board or stones via t

    Show normal when hitting board

    ============================================================

    When ray is not hitting stone, draw a yellow line between
    the intersection with the plane and the nearest point on
    the biconvex surface.

    This will let me verify that the nearest point on biconvex
    relative to another point is correct -- the point will always
    by definition be *outside* the biconvex, otherwise the pick ray
    would have hit the biconvex stone first.

    Visualize the normal at the nearest point on the surface
    so I can verify that the normal on biconvex surface is
    correct.

    ============================================================

    Implement biconvex vs. line intersection

    Assume that the line is infinite

    Based around nearest point on the line to the sphere,
    then it is just comparing the projected point to see
    if it is on the biconvex surface.

    ============================================================

    Implement left edge case SAT:

        1. may collide with primary plane
        2. may collide with left plane
        3. may collide with edge between primary and left plane

    Primary surface case is already implemented

    Left surface case is already implemented (plane again)

    Take the three cases and determine the area with the least
    collision. If any case is not intersecting, then no collision.

    Unit test edge cases:

        not colliding (vertically above)                            -
        not colliding (rotated such that not touching side plane)   |
        not colliding (rotated such that not touching side edge)    /

        colliding (rotated such that touching primary surface)      |
        colliding (rotated such that touching side surface)         -
        colliding (rotated such that touching edge)                 \

    Generalize fn so that it takes two planes as input, and finds
    the edge from these planes, and uses that to implement SAT.

    Therefore we should be comfortable that this case generalizes
    to the other edges without hard coding all these cases!

    Extend the to all edges.

    Unit test all edge cases.

    ============================================================

    Implement one corner case via SAT (top-left)

    Unit test corner case.

    Extend to all corners.

    ============================================================

    Biconvex vs. Biconvex

        Extend so that once we know intersection we can determine
        the point and normal to push out. Should this be done with
        SAT or some hand crafted test based on nearest features?

        I think with the SAT test the way it is sorted, I already know
        the nearest feature being considered, eg. it is a point on the
        sphere edge, or a point on the circle edge.

        In fact, by determining the point first, and skipping cases 
        where the nearest point feature is on the shadow side of the
        sphere, it will probably make the SAT test faster.

        I think that I should have two versions of the test

            1. A fast version that just determines intersecting yes/no

            2. A slow version that determines normal, point of intersection

        This would allow me to keep the simple test as is, and add a
        more complicated one that would track nearest feature etc.

        I should try to find a way to convert the simple binary SAT
        so that it doesn't require unit axis vectors. The sqrt here
        is going to significantly slow down the test.

    Physics:

        Once satisfied that the basic queries are good quality implement physics

        The idea would be that an impulse based simulation is probably the best
        way to go, ideally reusing the idea of speculative contacts so resting
        contact is completely stable with no jitter.

        First implement the stone drop with gravity with only linear motion

        Verify that the stone properly drops and bounces against the plane
        without linear motion and does not penetrate.

        Next, determine how to implement angular collision response

        Next, determine how to implement friction

        At this point the stone should bounce and move realistically.
