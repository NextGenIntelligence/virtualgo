DONE:

    ...

TODO:

    ===============================================================

    Work out the integral for the inertia tensor exactly

    Compare with the numerically integrated result until correct

    Does not match...

    At this point I am unsure which one is incorrect :)

    Actually, I found that the integral was only 1/2 of the inertia
    tensor, because it was only the top half of the stone. 

    After doubling the value, it seems that it is IN THE BALLPARK

    In fact, when comparing the approx value vs. the exact 
    ellipsoid value, it seems that the approx value is the
    incorrect one *because* the approx biconvex iy should
    be LESS than the ellipsoid one (less distant mass)

    So I should look over the approx integral and determine if
    there is any mistake there... perhaps I have the density
    calculation incorrect, or it is the point mass assumption
    that is throwing it off.

    Found it! I was not squaring the r coordinate. It needs
    to be squared, this also saves time because it removes
    the sqrt!

    ===============================================================

    THEORY #1:

    Energy is being added to the system when I push the stone up

    This is normally not a large amount, but if the stone rotates
    very rapidly, it can tunnel significantly and add potential
    energy when pushing up.

    It would be cool to determine how much energy I am adding
    by pushing the stone up, then remove this energy from the
    angular and linear component

    This way I should not add any energy to the system.

    In order to do this, I need to know the total energy of the
    stone, eg. kinetic energy of the rigid body + gravitational
    potential energy.

    ==============================================================

    THEORY #2:

    Somehow the coulomb friction forces are adding energy to the
    system. This would seem to make sense given that faster rotation
    of the stone is likely to greatly increase the normal force n,
    and increase the amount of friction applied.

    Could determine if this is the case by watching non-friction
    and see if it has the same oscilliation and energy add as
    the friction impulse does.

    ==============================================================

    I'm pretty sure at this point that it is theory #2, not #1

    The non-friction case appears to be much better behaved than
    the friction case.

    In order to fix this, I may need to study Mirich's derivation
    of the friction DE, to see how he avoids adding energy to the
    system (I would assume this is why it is non-trivial...)

    ===============================================================






    ==============================================================

    Basic Rendering

    Render the stone with a white texture

    Render the board with a wood texture

    What should the background be? Black? Grey?

    Render the lines and the circles at the star points (9x9)

    ==============================================================

    Advanced Rendering

    Enable anti-aliasing

    Enable anisotropic filtering

    Study the OpenGL shader guide to work out how to render stuff

    Write a function to determine the silhouette edge of a stone

    Implement silhouette edge for board so it can cast shadows
    on the floor.

    Add a toggle mode to rotate between different camera views

    Render a blurred out reflection of the stones on the board

    ============================================================







    ============================================================

    *** IMPLEMENT STONE VS. BOARD EDGE AND CORNER CASES! ***

    Implement biconvex vs. line intersection

    IMPORTANT: not ray intersection, but point/normal
    of intersection of biconvex against an edge!

    Assume that the line is infinite

    Based around nearest point on the line to the sphere,
    then it is just comparing the projected point to see
    if it is on the biconvex surface.

    ============================================================

    Implement left edge case SAT:

        1. may collide with primary plane
        2. may collide with left plane
        3. may collide with edge between primary and left plane

    Primary surface case is already implemented

    Left surface case is already implemented (plane again)

    Take the three cases and determine the area with the least
    collision. If any case is not intersecting, then no collision.

    Unit test edge cases:

        not colliding (vertically above)                            -
        not colliding (rotated such that not touching side plane)   |
        not colliding (rotated such that not touching side edge)    /

        colliding (rotated such that touching primary surface)      |
        colliding (rotated such that touching side surface)         -
        colliding (rotated such that touching edge)                 \

    Generalize fn so that it takes two planes as input, and finds
    the edge from these planes, and uses that to implement SAT.

    Therefore we should be comfortable that this case generalizes
    to the other edges without hard coding all these cases!

    Extend the to all edges.

    Unit test all edge cases.

    ============================================================

    Implement one corner case via SAT (top-left)

    Unit test corner case.

    Extend to all corners.

    ============================================================




 
    ============================================================

    Visualize stone vs. stone SAT

    Two stones rotating next to each other.

    Visualize their x/y axis supports for each stone.

    Add some vis when they are colliding.

    Consider whether or not we need additional separating
    axes than the current, it should be clear from the vis.

    ============================================================

    Implement nearest point on biconvex vs. biconvex

    This is required to determine the collision point and normal
    between two stones after bisecting to find intersection t.

    Visualize nearest points between biconvex if not intersecting
    in yellow.

    Add some key to move the biconvex further away from each other
    or closer together (left/right)

    ============================================================

    Generalize stones to an array of rigid bodies, array of
    biconvex shapes (don't assume all the same size...)

    Determine algorithm for detecting collisions globally

    Study speculative contacts approach and think through

    What about "ghost" contacts?!

    End result, should have a bunch of stones falling while you
    are holding space bar down. These stones should tumble and
    collide and come to rest on the board.
